v1
1.	Технологія розробки спеціалізованих застосувань  клієнт - сервер на базі протоколу HTTP. Варіанти застосування. Переваги та недоліки технології.
2.	Загальні поняття про геоінформаційні системи. Предмет і методи геоінформатики. Географічні і просторові дані. Компоненти геоданих.
1.	Технологія клієнт-сервер означає такий спосіб взаємодії програмних компонентів, при якому вони утворюють єдину систему. 
Переваги: дозволяє організовувати мережі з великою кількістю робочих станцій; спрощує мережеве адміністрування завдяки можливості централізованого управління обліковими записами; забезпечує   ефективний   доступ   до   мережевих   ресурсів   (без використання паролів доступу до ресурсів).
Недоліки архітектури «клієнт-сервер»: критична по відношенню до працездатності сервера; вимагає кваліфікованого персоналу для адміністрування мережі; підвищення вартості мережі через використання потужних серверів.
Подальше розширення дворівневої архітектури клієнт-сервер припускає поділ функціональної частини колишнього, «товстого» (інтелектуального) клієнта на дві частини. У трирівневій архітектурі клієнт-сервер «тонкий» (не інтелектуальний) клієнт на робочій станції управляє тільки користувацьким інтерфейсом, тоді як середній рівень опрацювання даних управляє всією іншою логікою роботи клієнтської програми.
Дворівнева архітектура клієнт-сервер. У цій архітектурі на виділеному сервері, що працює, як правило, під управлінням серверної операційної системи, встановлюють спеціальне програмне забезпечення (ПЗ) – сервер БД, наприклад, Microsoft SQL Server або Oracle. СУБД поділяється на дві частини: клієнтську й серверну. WWW – найбільш відомий сервіс мережі Internet, завдяки якому вона й набула величезної популярності серед користувачів. У даному випадку клієнт-серверна технологія застосовується при перегляді Web-сторінок. У ролі клієнтської програми виступає Web-браузер, який з допомогою протоколу HTTP відправляє запити серверу, на якому розміщені Web-сторінки. HTTP-протокол також широко використовують у «тонких» клієнтах, які будуть розглянуті нижче.
Трирівнева архітектура клієнт-сервер функціонує в Intranet та Internet мережах. Клієнтська частина («тонкий клієнт»), з яким працює користувач, є Web-браузером або прикладною клієнтською програмою, що взаємодіє із Web-сервісами. Уся програмна логіка винесена на сервер застосувань, що забезпечує формування запитів до БД, які передаються серверу баз даних для їх виконання. Сервер застосувань може бути Web-сервером або спеціалізованою серверною програмою (наприклад, Oracle Forms Server).
Для програмних засобів, що функціонують на основі протоколу HTTP, характерним є те, що користувачі працюють з ними за допомогою звичайних браузерів, таких, як Microsoft Internet Explorer. При цьому доступ до них здійснюється як до звичайних статичних HTML-сторінок за їх URL-адресою. Однак такі програмні засоби зовсім не схожі на статичні HTML-сторінки. За посередництвом Web-сервера вони можуть звертатися до різних об'єктів, служб і систем, таких, наприклад, як бази даних. Так, у відповідь на запит, введений користувачем у вікні браузера, Web-сервер може сформувати звіт і відобразити його у тому ж вікні. При цьому для одержання результату Web-сервер генерує запит до бази даних
2.	Геоінформаці́йна систе́ма — сучасна комп'ютерна технологія, що дозволяє поєднати модельне зображення території (електронне відображення карт, схем, космо-, аерозображень земної поверхні) з інформацією табличного типу (різноманітні статистичні дані, списки, економічні показники тощо). Також, під геоінформаційною системою розуміють систему управління просторовими даними та асоційованими з ними атрибутами. Конкретніше, це комп'ютерна система, що забезпечує можливість використання, збереження, редагування, аналізу та відображення географічних даних.
Предметом вивчення геоінформаційних систем є геоб’єкти, геосередовище, геопроцеси (природні та техногенні), а також - іноформація та інформацйійні технології.
Методом є ознайомлення з ГІС системами, які розробляються і застосовуються з метою розв’язання наукових і прикладних задач з моніторингу екологічних ситуацій, раціональному використанню природних ресурсів, а також інфраструктурного проектування, місцевого та регіонального планування, з метою прийняття оперативних заходів в умовах надзвичайних ситуацій.
Географічні дані – це дані, які описують певну частину поверхні Землі або об’єкти, що знаходяться на цій поверхні. Вони показують об’єкти з точки зору розташування їх на поверхні Землі, тобто представляють собою географічну карту місцевості.
Просторові дані – це дані про місце розташування об’єктів або поширенню явищ, які представлені в певній системі координат у словесному або числовому опису.
Географічні дані (геодані) містять чотири інтегрованих компоненти:
–географічне положення (розміщення) просторових об’єктів подається 2-х, 3-х або 4-мірними координатами в географічно співвіднесеній системі координат (широта / довгота);
–атрибути (семантичні дані) − властивість, якісна або кількісна ознака, яка характеризує просторовий об’єкт, але не пов’язана з його місцем розташування;
–просторові відношення − внутрішні взаємовідношення між просторовими об’єктами (наприклад, напрямок об’єкта А щодо об’єкта В, відстань між об’єктами А і В, вкладеність об’єкта А в об’єкт В тощо);
–часові характеристики подаються в вигляді строків одержання даних, визначають їх життєвий цикл (строків придатності або достовірності), зміну місця розташування або властивостей просторових об’єктів у часі.


v2
1.	Використання технології COM для створення клієнтського спеціалізованого програмного забезпечення для роботи по протоколу HTTP.
2.	Визначення геоінформаційної системи. Галузі застосування геоінформаційних систем. Відмінність ГІС від інших інформаційних систем. Ключові переваги ГІС.
2.Геоінформаці́йна систе́ма — сучасна комп'ютерна технологія, що дозволяє поєднати модельне зображення території (електронне відображення карт, схем, космо-, аерозображень земної поверхні) з інформацією табличного типу (різноманітні статистичні дані, списки, економічні показники тощо). Також, під геоінформаційною системою розуміють систему управління просторовими даними та асоційованими з ними атрибутами. Конкретніше, це комп'ютерна система, що забезпечує можливість використання, збереження, редагування, аналізу та відображення географічних даних.
Застосування ГІС є ефективним в різноманітних предметних областях, де важливі знання про взаємне розташування та форму об'єктів у просторі. 
Сфери застосування ГІС: Земельний кадастр і землекористування; Сільське господарство;  Екологія і природокористування; Геоурбаністика, містобудування, ландшафтна архітектура; Транспорт і комунікації; Керування регіонами і регіоналістика; Соціологія і політологія; Оперативне керування і планування за надзвичайних ситуації;  Криміналістика. Широкого застосування ГІС зазнали у правоохоронних органах, які за допомогою кримінальної картографії візуалізують в зручному вигляді великі масиви даних щодо скоєних правопорушень для подальшого глибинного аналізу і пошуку шляхів попередження в майбутньому потенційних злочинів; Демографія.
Таким чином, ГІС — це інформаційні системи, які від інших інформаційних систем відрізняються тим, що це, по-перше, автоматизовані інформаційні системи, орієнтовані на використання можливостей ЕОМ, по-друге, вони призначені для роботи з просторово-координованою інформацією, і, по-третє, ГІС здатні продукувати нове знання на основі використання досить широкого спектра аналітичних методів і процедур.
Ключові переваги ГІС: зручне для користувача відображення просторових даних; прийняття обгрунтованих рішень; інтеграція даних усередині організації; зручний засіб для створення картографічних зображень.
1.	Термін "СОМ" є скорочення фрази Competent Object Model - компонентна об'єктна модель. Суттю даної технології є те, що програми будуються з компонент, які складаються з об'єктів. Само по собі ця обставина не є останньою новиною в області программостроенія - модульна архітектура і об'єктно-орієнтований підхід до побудови програм давно є визнаними стандартами de facto. Новиною є те, що є цими компонентами і об'єктами - ними є безпосередньо виконуваний двійковий код. Чи не "включаються вихідні тексти" компільовані спільно з проектом, не «бібліотеки стандартних програм", що приєднуються лінкером, а безпосередньо виконувані файли, які ніяк не треба "пов'язувати" зі своїм проектом - їх достатньо зареєструвати в операційній системі і вони будуть доступні будь-якій програмі що виконується на даній машині. Тобто їх використання в своїй програмі проводиться "без використання операцій складання модуля".
Основним поняттям, яким оперує стандарт COM, є COM-компонент. Програми, побудовані на стандарті COM, фактично не є автономними програмами, а являють собою набір взаємодіючих між собою COM-компонентів. Кожен компонент має унікальний ідентифікатор (GUID) і може одночасно використовуватися багатьма програмами. Компонент взаємодіє з іншими програмами через COM-інтерфейси - набори абстрактних функцій і властивостей. Кожен COM-компонент повинен, як мінімум, підтримувати стандартний інтерфейс «IUnknown», який надає базові засоби для роботи з компонентом. Інтерфейс «IUnknown» включає в себе три методи: QueryInterface, AddRef, Release.
Windows API надає базові функції, що дозволяють використовувати COM-компоненти. Бібліотеки MFC і, особливо, ATL / WTL надають більш гнучкі та зручні засоби для роботи з COM. Бібліотека ATL від Microsoft до цих пір залишається найпопулярнішим засобом створення COM-компонентів. Але найчастіше COM-розробка залишається ще досить складною справою, програмістам доводиться вручну виконувати багато рутинних завдання, пов'язані з COM (особливо це помітно в разі розробки на C ++). Згодом (в технологіях COM + і особливо .NET) Microsoft спробувала спростити завдання розробки COM-компонентів.

v3
БІЛЕТ 3
1.	Сутність вимог ACID при роботі з даними в реляційних СКБД. Забезпечення транзакцій на стороні СКБД та програмного забезпечення.
2.	Модель потоків виконання в мовах високого рівня. Підходи до створення потоків виконання. Синхронізація та взаємодія потоків виконання.
2.	Характеристики транзакцій описуються в термінах ACID (Atomicity, Consistency, Isolation, Durability - неподільність, узгодженість, ізольованість, стійкість ).
Вимоги ACID були в головному сформульовані в кінці 70-х років :
-	Транзакція неподільна в тому сенсі, що є єдиним цілим. Усі її компоненти або мають місце, або немає. Не буває часткової транзакції. Якщо може бути виконана лише частина транзакції, вона відхиляється.
-	Транзакція є погодженою, тому що не порушує бізнес-логіку і стосунки між елементами даних. Ця властивість дуже важлива при розробці клієнт-серверних систем, оскільки в сховище даних поступає велика кількість транзакцій від різних систем і об'єктів. Якщо хоч би одна з них порушить цілісність даних, то усі інші можуть видати невірні результати.
-	Транзакція завжди ізольована, оскільки її результати самодостатні. Вони не залежать від попередніх або наступних транзакцій - ця властивість називається серіалізуємістю і означає, що транзакції в послідовності незалежні.
-	Транзакція стійка. Після свого завершення вона зберігається в системі, яку ніщо не може повернути в початковий (до початку транзакції ) стан, тобто відбувається фіксація транзакції, що означає, що її дія постійно навіть при збої системи. При цьому мається на увазі деяка форма зберігання інформації в постійній пам'яті як частина транзакції .
Управління вимогами  ACID бере на себе сервер. Програміст  повинен лише вибрати потрібний рівень ізоляції і розробити ефективні алгоритми обробки даних.
Механізм транзакцій в СКБД
Автоматичні транзакції. В  цьому  режимі  кожна  команда  ініціює  початок  нової  транзакції. Якщо команда виконана успішно, то зроблені нею  зміни  фіксуються, інакше – відміняються.                  Для транзакції, що складається з декількох команд, явно задається початок і завершення транзакції. 
Початок транзакції  - в журналі транзакцій фіксуються первинні значення змінюваних даних і момент початку транзакції 
Кінець транзакції: якщо в тілі транзакції не було помилок, то ця команда наказує серверу зафіксувати усі зміни, зроблені в транзакції, після чого в журналі транзакцій позначається, що зміни зафіксовані і транзакція завершена;
Створення усередині транзакції точки збереження: СУБД зберігає стан БД в поточній точці і привласнює збереженому стану ім'я точки збереження;
Переривання транзакції : коли сервер зустрічає цю команду, відбувається відкат транзакції, відновлюється первинний стан системи і в журналі транзакцій відмічається, що транзакція була скасована.
Явні транзакції
Для  явної  транзакції  вимагається  явна  вказівка  початку  і   завершення транзакції.
3.	Дженерики - це засоби загального програмування, які були додані до мови програмування Java у 2004 році у версії J2SE 5.0. Вони були розроблені для розширення системи типів Java, щоб дозволити "типу або методу оперувати об'єктами різних типів, одночасно забезпечуючи безпеку типу компіляції". Безпека типу компіляції аспектів не була досягнута повністю, оскільки в 2016 році було показано, що вона не гарантується у всіх випадках. Структура колекцій Java підтримує загальні засоби для вказівки типу об’єктів, що зберігаються в екземплярі колекції.
Ось типове використання такого роду (без Generics): 
1. List myIntList = new LinkedList(); 
 2. myIntList.add(new Integer(0));
 3. Integer x = (Integer) myIntList.iterator().next();
Властивості: сувора типізація, єдина реалізація, відсутність інформації про тип. Для того щоб використовувати клас як Generics, ми повинні прописати після імені класу <...>, куди можна підставити будь-яке ім'я, wildcard і т.д. Після того як було оголошено ім'я generic-типу його можна використовувати як звичайний тип всередині методу. І коли в коді буде оголошений, наприклад, List <Integer>, то Е стане Integer для змінної list (як показано нижче).
В Generics такж можна маніпулювати з інформацією, яка зберігається в змінних. Знищення інформації про тип:
List l = new ArrayList<String>();
Додаваня інформації про тип
List<String> l = (List<String>) new ArrayList();
List<String> l1 = new ArrayList();


v4
БІЛЕТ 4
1.	CGI. Призначення, платформи, технологія роботи, варіанти створення, мови програмування. Застосування для публікації інформації з баз даних.
2.	Шаблони (узагальнення) в мовах високого рівня. Синтаксис опису узагальненого класу та інтерфейсу. Конкретизація шаблонів.
1.	Загальношлюзовий інтерфейс (CGI) є інтерфейсом до сервера, який дозволяє розширити функціональні можливості сервера. Використовуючи CGI, можна працювати в діалоговому режимі з користувачами, які звертаються до вашого сайту. На теоретичному рівні, CGI дозволяє розширити можливості сервера щодо аналізу (інтерпретації) введення, що надходить від браузера, і повертати інформацію, засновану на введеної інформації користувача. На практичному рівні, CGI - це інтерфейс, що дозволяє програмісту записати програми, які легко зв'язуються з сервером.
CGI (від англ. Common Gateway Interface - «загальний інтерфейс шлюзу») - стандарт інтерфейсу, використовуваного для зв'язку зовнішньої програми з веб-сервером. Програму, яка працює за таким інтерфейсу спільно з веб-сервером, прийнято називати шлюзом, хоча багато хто воліє назви «скрипт» (сценарій) або «CGI-програма».

Оскільки гіпертекст є статичною за своєю природою, веб-сторінка не може безпосередньо взаємодіяти з користувачем. До появи JavaScript, не було іншої можливості відреагувати на дії користувача, крім як передати введені їм дані на веб-сервер для подальшої обробки.
Протокол CGI визначає стандартний спосіб для програм, щоб зв'язатися з сервером Веб. Без будь-яких спеціальних знань, можна записати програму на будь-якому машинному мові, що супроводжується і зв'язується з сервером Веб. Ця програма буде працювати з усіма серверами Веб, які розуміють протокол CGI.
Сам інтерфейс розроблений таким чином, щоб можна було використовувати будь-яку мову програмування, який може працювати зі стандартними пристроями введення-виведення. Такими можливостями володіють навіть скрипти для вбудованих командних інтерпретаторів операційних систем, тому в простих випадках можуть використовуватися навіть командні скрипти.
Ви можете використовувати будь-яку мову, який дозволяє робити наступне:
Друкувати в стандартному виведення; Читати зі стандартного вводу; Читати з змінних режимівю.
Два найбільш часто використовуваних мови для програмування CGI - це C і Perl (обидва з яких розглядаються в цій книзі). У обох є чіткі переваги і недоліки. Perl - мова дуже високого рівня, і в той же час потужна мова, особливо придатний для синтаксичного аналізу тексту. Хоча легкість використання, гнучкість, і потужність робить його мовою, привабливим для програмування CGI, його відносно великий розмір і більш повільна робота іноді робить його невідповідним для деяких додатків. Програми C менше за розміром, більш ефективні і забезпечують контроль за системою більш низького рівня, але більш складні для програмування, не мають легких вбудованих підпрограм обробки тексту, і їх важче налагодити.
Зв'язок CGI здійснюється стандартним вводом і виводом, що означає, що, якщо Ви знаєте, як друкувати і читати дані, використовуючи свою мову програмування, можна написати додаток сервера Веб. Крім аналізу введення і виведення, програмування додатків CGI майже еквівалентно програмування будь-якого іншого застосування. 
В основі взаємодії CGI-програм і бази даних лежать прості принципи:
• необхідне з'єднання із сервером баз даних і зареєструватися;
• вибрати базу даних, яка повинна використовуватися;
• відправити запит SQL на сервер і отримати дані;
• відключитися від сервера баз даних.
2.	Один потік - це одна одиниця виконання коду. Кожен потік послідовно виконує інструкції процесу, якому він належить, паралельно з іншими потоками цього процесу.
Слід окремо обговорити фразу «паралельно з іншими потоками». Відомо, що на одне ядро процесора, в кожен момент часу, доводиться одна одиниця виконання. Тобто одноядерний процесор може обробляти команди тільки послідовно, по одній за раз (в спрощеному випадку). Однак запуск декількох паралельних потоків можливий і в системах з одноядерними процесорами. В цьому випадку система буде періодично перемикатися між потоками, по черзі даючи виконуватися то одному, то іншому потоку. Така схема називається псевдо-паралелізмом. Система запам'ятовує стан (контекст) кожного потоку, перед тим як перейти на інший потік, і відновлює його після повернення до виконання потоку.
Багатопотокове програмування дозволяє розділити уявлення і обробку інформації на кілька «легких» процесів (light-weight processes), що мають загальний доступ як до методів різних об'єктів додатки, так і до їхніх полів. Нить незамінна в тих випадках, коли графічний інтерфейс повинен реагувати на дії користувача при виконанні певної обробки інформації. Потоки можуть взаємодіяти один з одним через основний «батьківський» потік, з якого вони стартували.
Як приклад можна привести деякий потік, який відповідає за надання інформації в інтерфейсі, який очікує завершення роботи іншого потоку, що завантажує файл, і одночасно відображає деяку анімацію або оновлює прогрес-бар. Крім того цей потік може зупинити завантажує файл потік при натисканні кнопки «Скасувати».
Життєвий цикл потоку
При виконанні програми об'єкт Thread може перебувати в одному з чотирьох основних станів: «новий», «працездатний», «непрацездатний» і «пасивний». При створенні потоку він отримує стан «новий» (NEW) і не виконується. Для перекладу потоку зі стану «новий» в «працездатний» (RUNNABLE) слід виконати метод start (), що викликає метод run ().
Потік може перебувати в одному з станів, що відповідають елементам статично вкладеного перерахування Thread.State:
NEW - потік створений, але ще не запущений;
RUNNABLE - потік виконується;
BLOCKED - потік блокований;
WAITING - потік чекає заплати за працю іншого потоку;
TIMED_WAITING - потік деякий час чекає закінчення іншого потоку;
TERMINATED - потік завершено.
Інтерфейс Runnable містить тільки один метод run ()Метод run () виконується при запуску потоку. Після визначення об'єкта Runnable він передається в один з конструкторів класу Thread.
//////////////////
v5
5	варіант
1. ISAPI. Призначення, платформи, технологія роботи, варіанти створення, мови програмування. Застосування для публікації інформації з баз даних.
Призначення, платформи
Інтерфейс Internet Server Application Program Interface (ISAPI) призначений для програмування додатків (API) інформаційних служб Інтернету (IIS). ISAPI складається з класів підтримки і структур, що беруть участь в програмній експлуатації IIS. Веб-додатки, що використовують ISAPI для взаємодії з IIS, реалізують цю взаємодію на веб-сервері Windows найбільш ефективним чином. При роботі з ISAPI рівень програмного забезпечення підтримки або інтерфейсів між IIS і веб-додатком сильно знижується. Все програмне забезпечення веб-додатків Microsoft прямо або побічно використовує технологію ISAPI. Технології Microsoft Application Server Pages (ASP) і .NET Framework побудовані як додатки ISAPI.
Технологія роботи
Додатки ISAPI можуть бути оформлені або у вигляді розширень, або у вигляді фільтрів.
•	ISAPI-розширення- це додаток IIS, яке є адресатом запиту, воно виконує дії, які веб-сервер не може виконувати сам (наприклад, звернення до бази даних). Розширення не впливає на параметри запиту, а використовує їх як вхідні дані. У цьому ISAPI-розширення нагадує CGI-додаток. ISAPI-розширення може бути викликано як явно (через запит видуhttp: // <URL / path> /isapiext.dll?paramstring), Так і неявно (через карту розширень, в якій вказані обробники для зареєстрованих типів файлів (mapping), або при виклику через фільтр). Розширення ISAPI - найбільш частий спосіб застосування ISAPI.
•	ISAPI-фільтр, На відміну від розширення, є свого роду посередником в обробці користувальницького запиту з моменту його отримання веб-сервером і до моменту відправлення відповіді. Фільтр може модифікувати запит або відповідь, викликати специфічний для конкретного запиту обробник і т.п., при цьому сам фільтр не є кінцевим оброблювачем. Фільтри ISAPI досить складні в розробці і сфера їх використання обмежена, як правило, рішенням таких завдань, як шифрування, журнал роботи, аутентифікація, стиснення даних.



Варіанти створення
Розширення ISAPI створюється у вигляді бібліотеки динамічного завантаження DLL. Звернення до такої бібліотеці виконується в документах HTML аналогічно поводженню до програм CGI - з форм або посилань, створених за допомогою тегів <FORM> і <A>.
Коли користувач звертається до розширення ISAPI, відповідна бібліотека DLL завантажується в адресний простір сервера Microsoft Information Server і стає його складовою частиною. Так як розширення ISAPI працює в рамках процесу сервера Microsoft Information Server, а не в рамках окремого процесу (як це відбувається при запуску програми CGI), воно може користуватися всіма ресурсами, доступними сервера. Це сприятливо позначається на продуктивності.
Мови програмування
Спочатку ISAPI поширювався серед розробників CGI як альтернатива програми CGI або як оновлення виконуваного файлу CGI. Багато виконуваних файлів CGI написані на C ++ або C, тому інтеграція існуючого веб-додатку CGI не дуже складна. ISAPI рекомендується для програмістів, що створюють (або вже створили) додаток на мові C ++. Крім усього іншого, код ISAPI створюється за допомогою неконтрольованого коду C ++. Нові можливості, пропоновані Visual Studio .NET для керованого коду C ++ в технології .NET Framework, не можна використовувати в проекті ISAPI.
2. Призначення об’єктів класів синхронізації в мовах високого рівня. Призначення та суть атомарних операцій. Особливості безпечних для потоків контейнерних типів.
Синхронізатори - допоміжні утиліти для синхронізації потоків, які дають можливість розробнику регулювати і / або обмежувати роботу потоків і надають більш високий рівень абстракції, ніж основні примітиви мови (монітори).
Semaphore - синхронізатор Semaphore реалізує шаблон синхронізації Семафор. Найчастіше, семафори необхідні, коли потрібно обмежити доступ до деякого загального ресурсу. У конструктор цього класу (Semaphore (int permits) або Semaphore (int permits, boolean fair)) обов'язково передається кількість потоків, якому семафор буде вирішувати одночасно використовувати заданий ресурс.
Доступ управляється за допомогою лічильника: спочатку значення лічильника одно int permits, коли потік заходить в заданий блок коду, то значення лічильника зменшується на одиницю, коли потік його покидає, то збільшується. Якщо значення лічильника дорівнює нулю, то поточний потік блокується, поки хто-небудь не вийде з блоку (як приклад з життя з permits = 1, можна привести чергу в кабінет в поліклініці: коли пацієнт залишає кабінет, блимає лампа, і заходить наступний пацієнт ).
Рассмотрим следующий пример. Существует парковка, которая одновременно может вмещать не более 5 автомобилей. Если парковка заполнена полностью, то вновь прибывший автомобиль должен подождать пока не освободится хотя бы одно место. После этого он сможет припарковаться.
import java.util.concurrent.Semaphore;

public class Parking {
    //Парковочное место занято - true, свободно - false
    private static final boolean[] PARKING_PLACES = new boolean[5];
    //Устанавливаем флаг "справедливый", в таком случае метод
    //aсquire() будет раздавать разрешения в порядке очереди
    private static final Semaphore SEMAPHORE = new Semaphore(5, true);

    public static void main(String[] args) throws InterruptedException {
        for (int i = 1; i <= 7; i++) {
            new Thread(new Car(i)).start();
            Thread.sleep(400);
        }
    }

    public static class Car implements Runnable {
        private int carNumber;

        public Car(int carNumber) {
            this.carNumber = carNumber;
        }

        @Override
        public void run() {
            System.out.printf("Автомобиль №%d подъехал к парковке.\n", carNumber);
            try {
                //acquire() запрашивает доступ к следующему за вызовом этого метода блоку кода,
                //если доступ не разрешен, поток вызвавший этот метод блокируется до тех пор,
                //пока семафор не разрешит доступ
                SEMAPHORE.acquire();

                int parkingNumber = -1;

                //Ищем свободное место и паркуемся
                synchronized (PARKING_PLACES){
                    for (int i = 0; i < 5; i++)
                        if (!PARKING_PLACES[i]) {      //Если место свободно
                            PARKING_PLACES[i] = true;  //занимаем его
                            parkingNumber = i;         //Наличие свободного места, гарантирует семафор
                            System.out.printf("Автомобиль №%d припарковался на месте %d.\n", carNumber, i);
                            break;
                        }
                }

                Thread.sleep(5000);       //Уходим за покупками, к примеру

                synchronized (PARKING_PLACES) {
                    PARKING_PLACES[parkingNumber] = false;//Освобождаем место
                }
                
                //release(), напротив, освобождает ресурс
                SEMAPHORE.release();
                System.out.printf("Автомобиль №%d покинул парковку.\n", carNumber);
            } catch (InterruptedException e) {
            }
        }
    }
}
CountDownLatch - CountDownLatch (замок із зворотним відліком) надає можливість будь-якій кількості потоків в блоці коду очікувати до тих пір, поки не завершиться певну кількість операцій, що виконуються в інших потоках, перед тим як вони будуть «відпущені», щоб продовжити свою діяльність. У конструктор CountDownLatch (CountDownLatch (int count)) обов'язково передається кількість операцій, яке повинне бути виконане, щоб замок «відпустив» заблоковані потоки.
Блокування потоків знімається за допомогою лічильника: будь-який діючий потік, при виконанні певної операції зменшує значення лічильника. Коли лічильник досягає 0, все очікують потоки розблоковуються і продовжують виконуватися (прикладом CountDownLatch з життя може служити збір екскурсійної групи: доки набереться певна кількість осіб, екскурсія не почнеться).
Рассмотрим следующий пример. Мы хотим провести автомобильную гонку. В гонке принимают участие пять автомобилей. Для начала гонки нужно, чтобы выполнились следующие условия:

1.	Каждый из пяти автомобилей подъехал к стартовой прямой;
2.	Была дана команда «На старт!»;
3.	Была дана команда «Внимание!»;
4.	Была дана команда «Марш!».
Важно, чтобы все автомобили стартовали одновременно.
import java.util.concurrent.CountDownLatch;

public class Race {
    //Создаем CountDownLatch на 8 "условий"
    private static final CountDownLatch START = new CountDownLatch(8);
    //Условная длина гоночной трассы
    private static final int trackLength = 500000;

    public static void main(String[] args) throws InterruptedException {
        for (int i = 1; i <= 5; i++) {
            new Thread(new Car(i, (int) (Math.random() * 100 + 50))).start();
            Thread.sleep(1000);
        }

        while (START.getCount() > 3) //Проверяем, собрались ли все автомобили
            Thread.sleep(100);              //у стартовой прямой. Если нет, ждем 100ms

        Thread.sleep(1000);
        System.out.println("На старт!");
        START.countDown();//Команда дана, уменьшаем счетчик на 1
        Thread.sleep(1000);
        System.out.println("Внимание!");
        START.countDown();//Команда дана, уменьшаем счетчик на 1
        Thread.sleep(1000);
        System.out.println("Марш!");
        START.countDown();//Команда дана, уменьшаем счетчик на 1
        //счетчик становится равным нулю, и все ожидающие потоки
        //одновременно разблокируются
    }

    public static class Car implements Runnable {
        private int carNumber;
        private int carSpeed;//считаем, что скорость автомобиля постоянная

        public Car(int carNumber, int carSpeed) {
            this.carNumber = carNumber;
            this.carSpeed = carSpeed;
        }

        @Override
        public void run() {
            try {
                System.out.printf("Автомобиль №%d подъехал к стартовой прямой.\n", carNumber);
                //Автомобиль подъехал к стартовой прямой - условие выполнено
                //уменьшаем счетчик на 1
                START.countDown();
                //метод await() блокирует поток, вызвавший его, до тех пор, пока
                //счетчик CountDownLatch не станет равен 0
                START.await();
                Thread.sleep(trackLength / carSpeed);//ждем пока проедет трассу
                System.out.printf("Автомобиль №%d финишировал!\n", carNumber);
            } catch (InterruptedException e) {
            }
        }
    }
}
CyclicBarrier - CyclicBarrier реалізує шаблон синхронізації Бар'єр. Циклічний бар'єр є точкою синхронізації, в якій вказана кількість паралельних потоків зустрічається і блокується. Як тільки все потоки приб, виконується опціонну дію (або не виконується, якщо бар'єр був ініціалізований без нього), і, після того, як воно виконано, бар'єр ламається і очікуючі потоки «звільняються». У конструктор бар'єру (CyclicBarrier (int parties) і CyclicBarrier (int parties, Runnable barrierAction)) обов'язково передається кількість сторін, які повинні «зустрітися», і, опціонально, дія, яка має відбутися, коли сторони зустрілися, але перед тим коли вони будуть «відпущені».
Бар'єр схожий на CountDownLatch, але головна відмінність між ними в тому, що ви не можете заново використовувати «замок» після того, як його лічильник досягне нуля, а бар'єр ви можете використовувати знову, навіть після того, як він зламається. CyclicBarrier є альтернативою методу join (), який «збирає» потоки тільки після того, як вони виконалися.
Рассмотрим следующий пример. Существует паромная переправа. Паром может переправлять одновременно по три автомобиля. Чтобы не гонять паром лишний раз, нужно отправлять его, когда у переправы соберется минимум три автомобиля.
import java.util.concurrent.CyclicBarrier;

public class Ferry {
    private static final CyclicBarrier BARRIER = new CyclicBarrier(3, new FerryBoat());
    //Инициализируем барьер на три потока и таском, который будет выполняться, когда
    //у барьера соберется три потока. После этого, они будут освобождены.

    public static void main(String[] args) throws InterruptedException {
        for (int i = 0; i < 9; i++) {
            new Thread(new Car(i)).start();
            Thread.sleep(400);
        }
    }

    //Таск, который будет выполняться при достижении сторонами барьера
    public static class FerryBoat implements Runnable {
        @Override
        public void run() {
            try {
                Thread.sleep(500);
                System.out.println("Паром переправил автомобили!");
            } catch (InterruptedException e) {
            }
        }
    }

    //Стороны, которые будут достигать барьера
    public static class Car implements Runnable {
        private int carNumber;

        public Car(int carNumber) {
            this.carNumber = carNumber;
        }

        @Override
        public void run() {
            try {
                System.out.printf("Автомобиль №%d подъехал к паромной переправе.\n", carNumber);
                //Для указания потоку о том что он достиг барьера, нужно вызвать метод await()
                //После этого данный поток блокируется, и ждет пока остальные стороны достигнут барьера
                BARRIER.await();
                System.out.printf("Автомобиль №%d продолжил движение.\n", carNumber);
            } catch (Exception e) {
            }
        }
    }
}

v6
1.Технологія розробки систем клієнт сервер з використанням MS SQL 
Server. Засоби проектування та розробки.
Найбільш ефективну роботу з централізованою БД забезпечує архітектура клієнт-сервер. На відмінну від системи віддаленої обробки, в котрій є лише один комп’ютер, клієнт-серверна система складається із великої кількості комп’ютерів, об’єднаних в мережу.
На сервері розміщується БД і встановлюється СКБД(MS SQL Server) – сервер баз даних. Сервер баз даних – це програмний компонент, який забезпечує збереження великих об’ємів інформації, її обробку і представлення користувачам.  Microsoft SQL Server — комерційна система керування базами даних, що розповсюджується корпорацією Microsoft. Мова, що використовується для запитів — Transact-SQL, створена спільно Microsoft та Sybase. 
На комп’ютері клієнті додаток-клієнт формує запит до БД. MS SQL Server забезпечує інтерпретацію запиту, його виконання, формування результату запиту та пересилку його на клієнтський комп’ютер. Клієнтський додаток інтерпретує його необхідним чином і представляє користувачу. 
Функції клієнтської програми розбиваються на наступні групи:
· введення-виведення даних (презентаційна логіка) - це частина коду клієнтської програми, яка визначає, що користувач бачить на екрані, коли працює з додатком;
· бізнес-логіка - це частина коду клієнтської програми, яка визначає алгоритм вирішення конкретних завдань програми;
· обробка даних всередині програми (логіка бази даних) - це частина коду клієнтської програми, яка пов'язує дані сервера з додатком. Для зв'язку з цим використовується процедурна мова запитів SQL, за допомогою якого здійснюється вибірка і модифікація даних в серверних MS SQL Server.
Сервер баз даних(MS SQL Server) в загальному випадку здійснює цілий комплекс дій по управлінню даними. Основними серед них є такі:
· виконання запитів користувачів на вибір і модифікацію даних і метаданих, одержуваних від клієнтських додатків, що функціонують на ПК локальної мережі;
· зберігання та резервне копіювання даних;
· підтримка цілісності даних згідно з визначеними в БД правил;
· забезпечення авторизованого доступу до даних на основі перевірки прав і привілеїв користувача;
· протоколювання операцій і ведення журналу транзакцій.
2.Основи CSS. Основні методології для організації та написання CSS-коду.
HTML використовується для структурування вмісту сторінки. CSS використовується для форматування цього структурованого вмісту.
CSS був створений для надання web-дизайнерам можливостей точного дизайну, підтримуваних всіма браузерами. 
Зовнішні стилі (external style sheets)
Застосовуються за допомогою елемента link, який повинен розташовуватися тільки всередині елемента head
<link rel="stylesheet" type="text/css" href="mystyle.css" media="all" />
Таблиці стилів документа (document style sheets)
називаються так тому, що розташовуються безпосередньо в HTML-документі і застосовуються лише до нього. CSS-стилі та коментарі розташовуються між відкриваючим і закриваючим тегами елемента style:
<style	type="text/css">
...
</ style>
Стилі, що підставляються в рядок (inline styles)
Іноді потрібно призначити стиль окремого елементу на сторінці, не застосовуючи зовнішніх стилів і елемента style. Типовий випадок - елемент зустрічається один раз в документі або на сайті, але вимагає особливого оформлення. Скористаємося атрибутом style (саме атрибутом елементів, а не елементом!):
<p	style="color:	red">
Я абзац, виділений червоним кольором, інших таких на сайті немає
</p>
Атрибут style є у всіх HTML-елементів, що розташовуються в елементі body. Усередині атрибуту style можна написати кілька CSS оголошень, розділених крапкою з комою, фігурні дужки не використовуються.

HTML селектор
Це найпростіший випадок - в якості селектора ми використовуємо ім'я html-елемента, який хочемо змінити. Наприклад, для тега <strong> селектором буде strong. Відповідно, для тега <h1> селектором буде h1, і так далі. Тепер можемо перевизначити зовнішній вигляд всіх таких елементів в нашому документі:
strong	{font-weight:	normal;	color:	red;}
h1 {font: bold 10pt verdana;}
Селектор класу
«Клас» - це деяке ім'я, яке ми можемо застосувати до будь-яких HTML-тегів, щоб згодом посилатися на них по імені класу. Як ім'я класу можна використовувати практично будь-який рядок. Зручність таких селекторів в тому, що можна присвоїти одне ім'я класу множині html-тегів у документі і потім управляти їх зовнішнім виглядом, звертаючись до них по імені класу:
.MyClass {font: bold 10pt verdana;}
Цей стиль міняє шрифт для всіх тегів з класом myClass



Найпопулярніші методології організації CSS-коду
БЕМ
Напевно, найпопулярніша зараз методологія в світі. Назва означає «Блок, елемент, модифікатор». Сам використовував на проектах і трішки знайомий з нею.
Складові:
блоки можуть використовуватися в декількох місцях сайту;
елементи є частиною блоку і не мають функціонального сенсу поза блоком;
модифікатори є властивості блоку або елементу, які змінюють його зовнішній вигляд або поведінку.
З цих складових будуються класи для безпосереднього використання в CSS. При цьому не слід використовувати селектори тегів (це потенційно може перешкодити використовувати блок / елемент в якомусь нестандартному місці на сайті, тобто прив’язує сутність до контексту); рекомендується також уникати каскадних селекторів, тому що отримана назва класу сама по собі досить точно (специфічно) вибирає відповідний елемент.
Такий підхід дозволяє позбутися від непередбачуваних наслідків каскаду і ізолює окремі модулі один від одного.
Мета методології БЕМ – «розробляти сайти, які необхідно швидко запустити і довго підтримувати. Методологія допомагає створювати розширюються та повторно використовувані компоненти інтерфейсу. »
Основна концепція – легка підтримка проектів з часом і повторне використання компонентів.
Головна стратегія БЕМ полягає в організації CSS-коду в повторно використовувані модулі за допомогою розумної системи іменування.
Приклад коду в стилі БЕМ:
.block_element {...} .block_element-modifier {...}
OOCSS
OOCSS означає об’єктно-орієнтований CSS (Object-Oriented CSS). В цей підхід закладено дві основні ідеї:
розділення	структури	і	оформлення:	
розділення контейнера і контенту (вмісту).
Отже, «розділяй і володарюй». За допомогою такої структури розробник отримує загальні класи, які можна використовувати в різних місцях. 
Крім того, сам підхід OOCSS пропонує не конкретні правила, а абстрактні рекомендації, тому метод досить складний для застосування на практиці.
Зате, як це іноді трапляється, деякі ідеї OOCSS надихнули авторів на створення своїх, більш конкретних, способів структурування коду – своєрідних ФОРКОМ OOCSS.
SMACSS
SMACSS розшифровується як «Швидка і модульна архітектура для CSS» (Scalable and Modular Architecture for CSS).
Основна мета підходу – зменшення кількості коду і на спрощення підтримки коду. 
Стилі складаються з 5 частин (в порядку включення їх в документ):
Base rules – базові стилі. Це стилі основних елементів сайту – body, input, button, ul, ol і т.п. У цій секції використовуються в основному селектори тегів і атрибутів, класи – в виняткових випадках (наприклад, якщо у вас стилізовані javascript’ом СЕЛЕКТА);
Layout rules – стилі макета. Тут знаходяться стилі глобальних елементів розміри шапки, футера, сайдбара і т.п. Пропонується використовувати тут id в селекторах, так як ці елементи не будуть зустрічатися більше 1 разу на сторінці. Як на мене то використання id в CSS це впринципі погана ідея і цього потрібно уникати. Ідентифікатори лише для JS прив’язок. Використовуйте класи і буде вам щастя.
Modules rules – стилі модулів, тобто блоків, які можуть використовуватися кілька разів на одній сторінці. Для класів модулів не рекомендується використовувати id і селектори тегів (для багаторазового використання та незалежності від контексту відповідно).
State rules – стилі стану. В цьому розділі прописуються різноманітні стани модулів і скелета сайту. Це єдиний розділ, в якому допустимо використання ключового слова «! Important». На мою думку, використання !important – погана практика, і CSS методологія повинна забезпечити уникнення цього інструменту.
Theme rules – оформлення. Тут описуються стилі оформлень, які з часом, можливо, потрібно буде замінити (так зручно робити, наприклад, новорічне оформлення; для html, виставлених на продаж такі стилі дозволяють перемикати колірну гамму і т.п.).
Також рекомендується вводити неймспейси для класів, що належать до певної групи, а також використовувати окремий неймспейс для класів, які використовуються в JavaScript.
Цей підхід дійсно дозволяє спростити написання і підтримку коду і останнім часом привертає чималу кількість розробників.
Atomic CSS
Atomic CSS, інколи також ACSS – атомарний CSS. У деякому роді цей підхід є OOCSS, зведений в абсолют. 
При використанні такого підходу для кожної повторно використовуваної властивості повинен бути сформований окремий клас. Приклад: стиль «margin-top: 1px» передбачає створення класу «mt-1», стиль «width: 200px» створення класу «w-200».
Такий стиль дозволяє мінімізувати обсяг CSS-коду за рахунок повторного використання декларацій, а також порівняно легко вводити зміни в модулі, наприклад, при зміні технічного завдання.
Однак у цього підходу є суттєві недоліки! Ось вони:
найменування класів є описові назви властивостей, які не описують семантичну сутність елемента, що іноді може ускладнити розробку;
настройки відображення елементів переносяться безпосередньо в HTML (це не те, для чого були придумані таблиці стилів, чи не так?).
У зв’язку з цими недоліками, підхід був зустрінутий істотним обсягом критики. Проте, підхід може виявитися ефективним для дуже великих проектів – здається, Yahoo! цілком задоволені використанням ACSS.
Крім того, атомарний CSS використовується в різних фреймворків для завдання коригувальних стилів елементів і в деяких шарах інших методологій.
ECSS
Enduring CSS (витривалий CSS) або eCSS. Документація – Сайт eCSS
Центральна концепція eCSS – ізоляція. Ізоляція означає, що всі компоненти являють собою ізольовану одиницю коду без залежностей, контексту. Цю одиницю можна використовувати повторно і видаляти без ризику витоку стилів.
В основному це досягається за рахунок:
інкапсуляції всього коду, не тільки CSS, а всіх технологій, необхідних для побудови всіх компонентів в своїх загальних папках;
створення абсолютно нового компонента кожен раз, коли потрібен компонент, схожий на вже існуючий, але в якому будуть деякі зміни, навіть якщо зміни незначні;
використання суворої системи іменування.
Другий пункт дає нам зрозуміти, що повторення властивостей і значень для eCSS не проблема. В цьому плані eCSS радикально відходить від таких методологій, як БЕМ і SMACSS, які розширюють і абстрагуються від існуючих компонентів, тим самим уникаючи або намагаючись якомога сильніше уникнути повторення коду.

v7
7 варіант
1.Технологія розробки багаторівневих систем клієнт- сервер на базі MS SQL Server.
Найбільш ефективну роботу з централізованою БД забезпечує архітектура клієнт-сервер. На відмінну від системи віддаленої обробки, в котрій є лише один комп’ютер, клієнт-серверна система складається із великої кількості комп’ютерів, об’єднаних в мережу.
Архітектура клієнт-сервер визначає загальні принципи взаємодії між комп'ютерами, деталі взаємодії визначають протоколи. Взаємодію починає клієнт, а правила, за якими відбувається взаємодія описує протокол.
Клієнт-серверні системи бувають двохрівневі (клієнт запитує сервіси у сервера) і трирівневі (запити обробляються проміжними серверами, які координують виконання клієнтських запитів з підлеглими їм серверами). Трирівневі архітектури взаємодії клієнт-сервер мають назву багаторівнева архітектура клієнт-сервер (іноді називають трьохланцюгова архітектура).
Суть багаторівневої архітектури - запит клієнта обробляється відразу декількома серверами. Розподіл операцій значно знижує навантаження на сервер, та даний підхід менш надійний ніж двохланцюгова архітектура.
 
В контексті систем, перший рівень - це клієнт, що надсилає SQL запити до бази даних; другий рівень - це СКБД (MS SQL Server), який реалізує взаємодію між клієнтом і сервером, а третій рівень - це сховище даних.
Формуванням для користувача інтерфейсу займається клієнт, для побудови якого використовувати ряд спеціальних інструментів, а також більшість настільних СКБД, в даному випадку вона представлена MS SQL Server. Логіка обробки даних може виконуватися і клієнтом, і сервером. Клієнт посилає на сервер запити, сформульовані, як правило, на мові SQL. Сервер обробляє їх і передає клієнту/клієнтам результат.
2.Призначення й особливості реалізації породжуючих та поведінкових шаблонів проектування.
Патерни бувають наступних трьох видів:
1.	Що породжують.
2.	Структурні.
3.	Поведінкові.
Якщо говорити простими словами, то це шаблони, які призначені для створення екземпляра об’єкту або групи пов’язаних об’єктів.
	Шаблони, що породжують – шаблони проектування, які абстрагують процес інстаціювання. Вони дозволяють зробити систему незалежною від способу створення, композиції і представлення об’єктів. Шаблон, що породжує класи, використовує спадкоємство, щоб змінювати успадковний клас, а шаблон, що породжує об’єкти, делегує інстанціювання іншому об’єкту.
Проста фабрика (Simple Factory) - У об’єктно-орієнтованому програмуванні (ООП), фабрика – це об’єкт для створення інших об’єктів. Формально фабрика – це функція або метод, який повертає об’єкти прототипу, що змінюється, або класу з деякого виклику методу, який вважається “новим”.
Проста фабрика генерує екземпляр для клієнта, не розкриваючи ніякої логіки.
Фабричний метод (Fabric Method) - шаблон проектування, що породжує, надає підкласам інтерфейс для створення екземплярів деякого класу. У момент створення спадкоємці можуть визначити, який клас створювати. Іншими словами, цей шаблон делегує створення об’єктів спадкоємцям батьківського класу. Це дозволяє використати в коді програми не специфічні класи, а маніпулювати абстрактними об’єктами на більш високому рівні. 
Менеджер надає спосіб делегування логіки створення екземпляра дочірнім класам.
Абстрактна фабрика (Abstract Factory) -  паттерн проектування, що породжує, надає інтерфейс для створення сімейств взаємозв’язаних або взаємозалежних об’єктів, не специфікуючи їх конкретних класів. Шаблон реалізується створенням абстрактного класу Factory, який є інтерфейсом для створення компонентів системи (наприклад, для віконного інтерфейсу він може створювати вікна і кнопки). Потім пишуться класи, що реалізовують цей інтерфейс.
 Фабрика фабрик. Фабрика, яка групує індивідуальні, але пов’язані/залежні фабрики без вказівки їх конкретних класів.
Будівельник (Builder) - шаблон проектування, що породжує, який надає спосіб створення складеного об’єкту. Призначений для вирішення проблеми антипатерну “Телескопічний конструктор”.
Шаблон дозволяє вам створювати різні види об’єкту, уникаючи засмічення конструктора. Він корисний, коли може бути декілька видів об’єкту або коли потрібна безліч кроків, пов’язаних з його створенням.
Прототип (Prototype) - задає види створюваних об’єктів за допомогою екземпляра-прототипу і створює нові об’єкти шляхом копіювання цього прототипу. Він дозволяє піти від реалізації і дозволяє наслідувати принцип “програмування через інтерфейси”. В якості повертаючого типу вказується інтерфейс / абстрактний клас на вершині ієрархії, а класи-спадкоємці можуть підставити туди спадкоємця, що реалізовує цей тип.
Прототип створює об’єкт, грунтований на існуючому об’єкті за допомогою клонування.
Одинак (Singleton) - шаблон проектування, що породжує, гарантує, що в однопроцесному застосуванні буде єдиний екземпляр деякого класу, і що надає глобальну точку доступу до цього екземпляра.
Забезпечує той факт, що створюваний об’єкт є єдиним об’єктом свого класу.

Поведінкові патерни використовуються для того, щоб спростити взаємодію між сутностями.
Template Method (Шаблоновий метод) - визначає основу алгоритму і дозволяє спадкоємцям перевизначити деякі кроки алгоритму, не змінюючи його структуру в цілому.
Mediator (Посередник) - надає клас посередника, який обробляє всі комунікації між різними класами.
Chain of Responsibility (Ланцюжок обов'язків) - дозволяє уникнути жорсткої залежності відправника запиту від його одержувача, при цьому запит може бути оброблений кількома об'єктами.
Observer (Спостерігач) - дозволяє одним об’єктам стежити і реагувати на події, що відбуваються в інших об'єктах.
Strategy (Стратегія) - алгоритм стратегії може бути змінений під час виконання програми.
Command (Команда) - інтерфейс команди оголошує метод для виконання певної дії.
State (Стан) - об'єкт може змінювати свою поведінку в залежності від його стану.
Visitor (Відвідувач) - використовується для спрощення операцій над угрупованнями пов'язаних об'єктів.
Interpreter (Інтерпретатор) - визначає граматику простої мови для проблемної області.
Iterator (Итератор) - послідовно здійснює доступ до елементів об'єкта колекції, не знаючи його основного уявлення.
Memento (Хранитель) - використовується для зберігання стану об'єкта, пізніше цей стан можна відновити.
/////////////////////////////////////
v8
Технологія розробки систем клієнт сервер на базі MySQL.
Базовим принципом цієї системи є централізація зберігання і обробки даних
На сервері встановлюються серверна операційна система, розміщується БД та потужна серверна СКБД(MySQL) - сервер баз даних, який забезпечує зберігання великих обсягів інформації, її обробку та подання користувачам. 
На комп'ютерах-клієнтах, встановлюються клієнтські програми (прикладні програми) і операційна система для робочих станцій.
Описана архітектура клієнт / сервер складається з сервера і клієнтських комп'ютерів.
Три рівнева архітектура має на увазі наявність крім сервера баз даних, виділеного сервера додатків, що містить основну частину програм обробки інформації.
Клієнтський комп'ютер звертається до сервера, який в свою чергу формує SQL-запит до БД. MySQL забезпечує виконання запиту, формує результат і пересилання його по мережі на сервер, який відправляє його користувачеві. Крім запитів на вибірку можуть надсилатися запити на оновлення БД, і сервер баз даних внесе в неї необхідні зміни.
Оскільки клієнту по мережі передається тільки результат запиту, то в мережі практично не виникає «заторів». Основне навантаження лягає на сервер, який має більші ресурси ніж клієнти і тому здатний швидше обслуговувати запити. В результаті зменшується потреба клієнтських додатків в оперативній пам'яті.
При зверненні одночасно декількох клієнтів до одних і тих же даних сервер дозволяє розділити виконання їх запитів в часі. Отже підвищується ступінь безпеки БД, так як правила цілісності даних визначаються сервером і є єдиними для всіх додатків, що використовують цю БД.
2.Узагальнена структурна схема клієнт-серверної взаємодії на основі сервісу електронної пошти. Загальна характеристика сучасних поштових серверів та клієнтів.
Типова система електронної пошти складається з поштового сервера та клієнтів. 
 
 
Поштовий сервер — програма, що забезпечує роботу служби із сторони Інтернету. Як і всі служби Інтернету, електронна пошта заснована на взаємодії двох програм. Одна з цих програм — сервер, а інша — клієнт. Вони взаємодіють за визначеними правилами, заданими у протоколах. Поштовий клієнт - це програма, яка встановлена на комп'ютері користувача й забезпечує взаємодію з поштовим сервером.
Наприклад, в поширених конфігураціях клієнтом пошти користувача є Outlook Express, повноцінна версія Microsoft Outlook, або Mozilla Thunderbird. Коли користувач набрав повідомлення і посилає його одержувачу, поштовий клієнт взаємодіє з поштовим сервером, використовуючи протокол SMTP. Поштовий сервер відправника взаємодіє з поштовим сервером одержувача (безпосередньо або через проміжний сервер — релей). На поштовому сервері одержувача повідомлення потрапляє в поштову скриньку, звідки за допомогою агента доставки повідомлень (англ. mail delivery agent, MDA) доставляється клієнту одержувача. Часто останні два агенти суміщені в одній програмі (наприклад, sendmail), хоча є спеціалізовані MDA, які в тому числі займаються фільтрацією спаму. Для фінальної доставки отриманих повідомлень використовується не SMTP, а інший протокол — часто POP3 або IMAP — який також підтримується більшістю поштових серверів. Хоча у найпростішій реалізації MTA досить покласти отримані повідомлення в особисту теку користувача у файловій системі центрального сервера («поштова скринька»).
Поштовий клієнт, клієнт електронної пошти, емейл-клієнт — комп'ютерна програма, яка встановлюється на комп'ютері користувача і призначена для одержання, написання, відправлення та зберігання повідомлень електронної пошти одного або декількох користувачів (у випадку, наприклад, кількох облікових записів на одному комп'ютері) або декількох облікових записів одного користувача.
На відміну від поштового сервера, клієнт електронної пошти зазвичай відправляє повідомлення не прямо на відповідний сервер одержувача, а на один і той же поштовий сервер, який виступає як релей. Зазвичай це поштовий сервер провайдера або компанії. Відправка пошти найчастіше здійснюється за протоколом SMTP. Клієнт електронної пошти приймає пошту з одного або декількох поштових серверів, часто це той же сервер, котрий слугує для відправки. Прийом пошти зазвичай здійснюється за протоколами POP або IMAP.
Також в функції клієнта електронної пошти може входити: сортування, зберігання повідомлень, пошук по архіву повідомлень, ведення адресної книги, фільтрація прийнятих повідомлень за різними критеріями, конвертація форматів, шифрування, організація інтерфейсів з офісними програмами та інші функції.
////////////////
v9
1. Дайте визначення СКБД, розкрийте її функції та архітектуру. Загальна характеристика реляційного підходу.
Система керування базами даних (СКБД) – сукупність мовних і програмних засобів, які призначені для створення, ведення і сумісного використання бази даних багатьма користувачами.
 


До головних функцій СКБД належать такі:
•	управління даними безпосередньо в БД – функція, що забезпечує зберігання даних, що безпосередньо входять до БД і службової інформації, що забезпечує роботу СКБД;
•	управління даними у зовнішній пам’яті  функція, яка пов’язана в першу чергу з тим, що СКБД працюють із БД великого розміру. В цілях прискорення роботи СКБД використовується буферизація даних в оперативній пам’яті комп’ютера. При цьому користувач СКБД використовує тільки необхідну для його конкретної задачі частину БД, а при необхідності одержує нову „порцію” даних. СКБД підтримує власну систему іменування об’єктів БД;
•	управління буферами оперативної пам’яті. СКБД зазвичай працюють з БД значного розміру; принаймні цей розмір зазвичай істотно більше доступного об’єму оперативної пам’яті. Зрозуміло, що якщо при зверненні до будь-якого елементу даних буде проводитися обмін із зовнішньою пам’яттю, то вся система буде працювати зі швидкістю пристрою зовнішньої пам’яті. Практично єдиним способом реального збільшення цієї швидкості є буферизація даних в оперативній пам’яті. 
•	управління транзакціями  функція СКБД, яка проводить ряд операцій над БД як над єдиним цілим. Як правило, такі операції проводяться в пам’яті комп’ютера. В першу чергу транзакції необхідні для підтримки логічної цілісності БД в розрахованих на багато користувачів системах. Якщо транзакція (деякий програмний код, написаний на одній з мов маніпулювання даними) успішно виконується, то СКБД вносить відповідні зміни в БД. У зворотному випадку жодна із зроблених змін ніяк не впливає на стан БД. Транзакція дозволяє повернути базу в початкове несуперечливе стан (скасувати всі виконані зміни);
•	управління паралельним доступом;
•	відновлення БД;
•	підтримка мов БД.  СКБД включає мову визначення даних, за допомогою якого можна визначити структуру бази, тип даних в ній, вказати обмеження цілісності (це мова, за допомогою якого задаються різні імена, властивості об’єктів). Крім того, СКБД дозволяє вставляти, видаляти, оновлювати і витягувати інформацію з бази даних за допомогою мови маніпулювання даними даними  мови запитів, що дозволяє виконувати різні дії з даними (занесення даних, видалення, модифікація, вибірка і т.д.). Вона містить набір різних операторів. 

Розрізняють три рівні архітектури БД 
 
Трирівнева архітектура СКБД дозволяє забезпечити незалежність від даних. Це означає, що зміни на нижніх рівнях не впливають на верхні рівні. 

Загальна характеристика реляційного підходу
Реляційна модель даних — логічна модель даних. В даний час ця модель є фактичним стандартом, на який орієнтуються практично всі сучасні комерційні системи керування базами даних (СКБД).
До складу реляційної моделі даних зазвичай включають теорію нормалізації. Визначиають три складові частини реляційної моделі даних:
	структурна
	маніпуляційна
	цілісна
Переваги реляційної моделі:
	простота і доступність для розуміння користувачем. Єдиною використовуваною інформаційною конструкцією є «таблиця»;
	суворі правила проектування, які базуються на математичному апараті;
	повна незалежність даних. Зміни в прикладній програмі при зміні реляційної БД мінімальні;
	для організації запитів і написання прикладного ПЗ немає необхідності знати конкретну організацію БД у зовнішній пам'яті.
Недоліки реляційної моделі:
	далеко не завжди предметна область може бути представлена у вигляді «таблиць»;
	в результаті логічного проектування з'являється множина «таблиць». Це призводить до труднощів розуміння структури даних;
	БД займає відносно багато зовнішньої пам'яті;
	відносно низька швидкість доступу до даних.
Реляційна база даних — база даних, заснована на реляційній моделі даних. Для роботи з реляційними БД застосовують реляційні СКБД. Інакше кажучи, реляційна база даних — це база даних, яка сприймається користувачем як набір нормалізованих відношень різного ступеня.
Реляційна база даних є сукупністю елементів даних, організованих у вигляді набору формально описаних таблиць, з яких дані можуть бути доступними або повторно зібрані багатьма різними способами без необхідності реорганізації таблиць бази даних.

	2.Фізична та логічна структуризація мереж. Алгоритм роботи “прозорого мосту”.
  Під фізичною топологією розуміють конфігурацію зв'язків, утворених окремими частинами кабеля, а під логічною - конфігурація інформаційних потоків між комп'ютерами мережі. У більшості випадків фізична та логічна топології співпадають. Найпростіший з комунікаційних пристроїв – повторювач (repeator) – використовується для фізичного з'єднання різноманітних сегментів кабелю локальної мережі з метою збільшення загальної довжини мережі. Повторювач передає сигнали, що приходять з одного сегмента мережі, в інші її сегменти. Повторювач дозволяє перебороти обмеження на довжину ліній зв'язку за рахунок поліпшення якості переданого сигналу – відновлення його потужності й амплітуди, поліпшення фронтів.
 Повторювач, що має декілька портів і з'єднує декілька фізичних сегментів, часто називають концентратором (concentrator) або хабом (hub). Ці назви (hub – основа, центр діяльності) відбивають той факт, що в даному пристрої зосереджуються всі зв'язки між сегментами мережі. Концентратори характерні практично для всіх базових технологій локальних мереж – Ethernet, ArcNet, Token Ring, FDDI, Fast Ethernet, Gigabit Ethernet, 100VG-AnyLAN.
  В роботі концентраторів будь-яких технологій багато спільного – вони повторюють сигнали, що прийшли від одного зі своїх портів, на інших своїх портах. Різниця полягає в тому, на яких саме портах повторюються вхідні сигнали. Так, концентратор Ethernet повторює вхідні сигнали на усіх своїх портах, крім того, із якого сигнали надходять (Рис.1.2 а). А концентратор Token Ring (Рис.1.2 б) повторює вхідні сигнали, що надходять із деякого порту, тільки на одному порту – на тому, до якого підключений наступний комп'ютер у кільці.
      Фізична структуризація мережі за допомогою концентраторів корисна не тільки для збільшення відстані між вузлами мережі, але і для підвищення її надійності. Наприклад, якщо якийсь комп'ютер мережі Ethernet із фізичною загальною шиною через збій починає безперервно передавати дані кабелем, то вся мережа виходить із ладу, і для вирішення цієї проблеми залишається тільки один вихід – вручну від’єднати мережевий адаптер цього комп'ютера від кабелю. У мережі Ethernet, побудованій з використанням концентратора, ця проблема може бути вирішена автоматично – концентратор відключає свій порт, якщо виявляє, що приєднаний до нього вузол занадто довго монопольно займає мережу. Концентратор може блокувати вузол, що працює некоректно, і в інших випадках, виконуючи роль керуючого вузла.
	Логічна структуризація мережі – це процес розбивки мережі на сегменти з локалізованим трафіком.Для логічної структуризації мережі використовуються такі комунікаційні пристрої:
	мости;
	комутатори;
	маршрутизатори;
	шлюзи.

       Міст (bridge) поділяє розподілене середовище передачі даних на частини, передаючи інформацію з одного сегмента в інший тільки у тому випадку, коли така передача дійсно необхідна, тобто якщо адреса комп'ютера призначення належить іншій підмережі. Тим самим міст ізолює трафік однієї підмережі від трафіка іншої, підвищуючи загальну продуктивність передачі даних у мережі. Локалізація трафіка не тільки заощаджує пропускну здатність, але і зменшує можливість несанкціонованого доступу до даних, тому що кадри не виходять за межі свого сегмента і їх складніше перехопити зловмиснику.
  Комутатор (switch) за принципом опрацювання кадрів нічим не відрізняється від моста. Основна його відмінність від моста полягає в тому, що кожен його порт оснащений спеціалізованим процесором, що опрацьовує кадри за алгоритмом моста незалежно від процесорів інших портів. За рахунок цього загальна продуктивність комутатора набагато вище продуктивності традиційного моста, що має один процесорний блок. Комутатори – це мости нового покоління, що опрацьовують кадри в паралельному режимі. Функції комутатора локальної мережі:
	Забезпечення наскрізної комутації.
	Наявність засобів маршрутизації.
	Підтримка простого протоколу управління мережею.
	Імітація моста або маршрутизатора.
	Організація віртуальних мереж.
	Швидкісна ретрансляція блоків даних.
 Маршрутизатор - комунікаційний пристрій, що утворює логічні сегменти за допомогою явної адресації, оскільки використовує не плоскі апаратні, а складові числові адреси. У цих адресах є поле номера мережі, так що всі комп'ютери, у яких значення цього поля однакове, належать до одного сегменту.Крім локалізації трафіка, маршрутизатори працюють в мережі з замкнутими контурами, при цьому здійснюючи вибір найбільш раціонального маршруту з декількох можливих.Іншою дуже важливою функцією маршрутизаторів є їх спроможність зв'язувати в єдину мережу підмережі, побудовані з використанням різних мережевих технологій, наприклад Ethernet і Х.25.
Маршрутизатори, як і мости або комутатори ретранслюють пакети з однієї частини мережі в іншу.
Перераховані пристрої передають кадри з одного свого порту на інший, аналізуючи адресу призначення, що поміщена в цих кадрах. (На відміну від концентраторів, які повторюють кадри на всіх своїх портах, передаючи їх в усі приєднані до них сегменти, незалежно від того, у якому з них перебуває станція призначення). Мости й комутатори виконують операцію передачі кадрів на основі плоских адрес канального рівня, тобто Мас-адрес, а маршрутизатори - на основі номера мережі. При цьому єдине поділюване середовище, створене концентраторами (або в граничному випадку - одним сегментом кабелю), поділяється на декілька частин, кожна з яких приєднана до порту моста, комутатора або маршрутизатора.
	Алгоритм роботи “прозорого мосту”
Алгоритм "прозорий міст" названий так тому, що присутність і робота моста є прозорими для хостів мережі.
Міст будує свою адресну таблицю на основі пасивного спостереження за трафіком, що проходить через його порти. При цьому витягується інформація про адреси джерел кадрів даних. За адресою джерела робиться висновок про належність конкретного вузла того чи іншого сегменту мережі. Процес створення адресної таблиці моста можна розглянути на прикладі простої мережі, що складається з двох сегментів (рис. 13, табл. 2)
 
Кожен порт працює як кінцевий вузол сегмента мережі. Спочатку міст нічого не знає про те, вузли з якими MAC-адресами підключені до кожного з його портів. Тому він передає будь-який отриманий кадр на всі свої порти, за винятком того, від якого він був отриманий. Одночасно з такою передачею міст вивчає адресу джерела кадру і заповнює свою таблицю на предмет приналежності конкретного порту (MAC-адреси) того чи іншого сегменту.
В подальшому міст використовує свою таблицю в якості базису для просування трафіку. Коли на один з інтерфейсів моста прийнятий блок даних, міст шукає адресу пункту призначення цього блоку даних у своїй внутрішній таблиці. Якщо таблиця містить взаємозв'язок між адресою пункту призначення і будь-яким з портів цього моста, за винятком того, в якому був прийнятий цей блок даних, то блок даних просувається із зазначеного порту. Якщо не знайдено жодного взаємозв'язку, то блок даних відправляється лавинної адресацією в усі порти, крім порту входження блоку даних. Широкомовні повідомлення і повідомлення багатопунктовий адресації відправляються лавинної адресацією таким же чином.
Прозорий міст успішно ізолює внутрішньосегментний трафік, тим самим скорочуючи трафік, видимий в кожному окремому сегменті. Це зазвичай зменшує час реакції мережі, видиме користувачеві. Ступінь скорочення трафіку і зменшення часу реакції залежать від обсягу межсегментного трафіку щодо загального трафіку, а також від обсягу широкомовного і багатопунктовий трафіку.
Суттєвою перешкодою, що порушує правильну роботу алгоритму "прозорого моста" є наявність "петель" в мережі, як це показано на рис. 5.
 
Припустимо, що хост А відправляє блок даних в хост В. Обидва мости приймають цей блок даних і і роблять правильний висновок про те, що машина А знаходиться в мережі 2. На жаль, після того, як машина В прийме два примірника блоку даних машини А , обидва мости знову отримують цей же блок даних на свої інтерфейси з Мережею 1, тому що всі хости приймають всі повідомлення широкомовних LAN. У деяких випадках мости потім змінюють свої внутрішні таблиці, щоб вказати, що машина А знаходиться в Мережі 1. У цьому випадку при відповіді машини В на блок даних машини А обидва мости візьмуть, а потім проігнорують ці відповіді, тому що їх таблиці вкажуть, що даний пункт призначення (машина А) знаходиться в тому ж сегменті мережі, що і джерело цього блоку даних.







v10
Білет №10
1.Дайте визначення поняттю база даних та розкрийте загальні відомості та архітектуру БД. Розкрийте поняття домену та атрибуту в реляційній моделі даних.
БАЗА ДАНИХ – сукупність спеціальним чином організованих даних, що зберігаються в пам’яті комп’ютера і відображають стан об’єктів та їх відносин у предметній області, що розглядається.
База даних повинна мати певні ВЛАСТИВОСТІ: 
• здатність до відновлення – можливість відновлення бази даних після збою системи. 
• безпека – припускає захист даних від навмисного і ненавмисного доступу, захист від копіювання, заборона несанкціонованого доступу. 
• цілісність - кожний момент часу існування бази даних відомості, що містяться в ній, повинні бути повними, несуперечливими і адекватно відображають предметну область.
• ефективність – мінімальний час реакції на запит користувача. 
Існує три основні типи МОДЕЛЕЙ БАЗ ДАНИХ:
1.Реляційна модель.
Дані зберігаються у вигляді відношень, кожна з яких описує окремий предмет, ситуацію чи явище у вигляді одного і того ж набору характеристик. 
У найпростішому вигляді ця модель реалізується у вигляді таблиці, стовпці якого містять характеристики, і називаються полями. 
Реляційна модель має наступні характеристики: 
• кожна стрічка таблиці – це один елемент даних.
• кожне поле таблиці має певний тип даних, котрий може мати обмеження.
• кожне поле має унікальне ім’я.
• у таблиці немає однакових записів.
2. Ієрархічна модель.
Сукупність ознак та властивостей об’єктів організовані ієрархічно.
Ця модель характеризується такими параметрами як рівні, вузли, зв’язки.
Ієрархічна модель має такі властивості:
• кілька вузлів нижчого рівня зв’язані тільки з одним вузлом вищого рівня.
• ієрархічне дерево має лише один вузол, що не має вищого за себе вузла.
• кожен вузол має унікальне ім’я.
3. Мережева модель.
Досить схожа на ієрархічну, але у ній можливий вільний зв'язок між окремими елементами різних рівнів. Такі зв’язки називаються асоціаціями і відображає логічні зв’язки між ними. 
ДОМЕН – безліч допустимих однорідних значень для того чи іншого атрибуту. Домен можна представити як іменовану безліч однорідних даних складової частини, в якої є логічно неділимі одиниці. Для відношення передбачається первинний ключ. Ним може виступати один або декілька атрибутів, значення яких унікальні і одночасно має ряд унікальних властивостей:
АТРИБУТ – компонент відношення, що називається стовпцем. Вони мають унікальні імена.
2.Комутатори Cisco в мережах Ethernet: принцип роботи, основні характеристики, область застосування, порівняльний аналіз різновидів внутрішньої архітектури (спільна шина, комутаційна матриця, поділювана пам’ять).
КОМУТАТОР - це спеціальне обладнання, яке дозволяє з'єднати кілька мереж або комп'ютерів в одну мережу. Таким чином, через комутатор надходить інформація, яка передається по цій мережі. Перевага саме комутаторів Cisco, полягає в тому, що передача даних відбувається на дуже високих швидкостях. Особливо, це важливо коли необхідно підключити до однієї мережі величезну кількість комп'ютерів.
Переваги комутаторів Cisco:
• висока якість обслуговування.
• високий рівень доступу.
• мінімальні витрати на електроенергію та інші ресурси.
• безпечне використання.
ПРИНЦИП РОБОТИ:
Комутатор отримує дані від пристроїв, які до нього звертаються, і поступово заповнює таблицю комутації їх MAC-адресами. При наступних зверненнях комутатор зчитує адресу пристрою-відправника, аналізує таблицю комутації і визначає по ній, на який пристрій потрібно переслати дані. Інші комп'ютери при цьому не знають про факт передачі інформації, оскільки вони не мають до них відношення. Завдяки цьому забезпечується робота мережі в full duplex режимі.
Новий комутатор на етапі навчання, не виявляючи у своїй таблиці MAC-адресу одержувача, розсилає дані на всі підключені до нього пристрої. Правильний одержувач відповідає комутатору, і останній створює новий запис в таблиці комутації. Надалі комутатор, приймаючи дані з цією ж MAC-адресою, розуміє, куди саме їх потрібно направити, і виробляє вже не масову розсилку, а строго адресну відправку. Трафік, таким чином, локалізується, а мережа - розвантажується.
МОЖЛИВОСТІ КОМУТАТОРІВ CISCO:
1.Одночасне підключення 8, 24 або 48 клієнтських пристроїв в залежності від моделі. 
2.Підтримка технології PoE (живлення через виту пару бездротових точок доступу, IP-телефонів). 
3.Наявність вбудованих функцій безпеки, підтримка NAC (технології контролю доступу до мережі).
4. Мережевий комутатор Cisco серії 2 має широкі можливості для створення відмовостійкої мережевої середовища. 
5.Регулювання швидкості передачі даних для будь-якого порту. 
6.Налаштування VLAN. Всі порти підтримують транкові з'єднання. На одному пристрої може бути налаштоване до 255 віртуальних локальних мереж.
Область застосування комутаторів широка, найпоширеніші ОБЛАСТІ ЗАСТОСУВАННЯ:
• домашня локальна мережа, що включає, наприклад, кілька комп'ютерів, принтер, телевізор і музичний центр;
• локальна мережа підприємства / офісу, з великою кількістю комп'ютерів та офісної техніки;
• системи «розумний дім» - з підключенням величезної кількості датчиків;
• системи відеоспостереження - якщо система велика, камер багато, то крім контролера для підключення всіх камер доцільно використовувати комутатор;
• промислові локальні мережі, які об'єднують датчики, які контролюють процес виробництва і диспетчерські центри.
КОМУТАТОРИ НА ОСНОВІ КОМУТАЦІЙНОЇ МАТРИЦІ.
Комутаційна матриця - основний і найшвидший спосіб взаємодії процесорів портів. Однак, реалізація матриці можлива тільки для певного числа портів.
Матриця складається з трьох рівнів двійкових перемикачів, які з'єднують свій вхід з одним з двох виходів в залежності від значення біта тега. 
Відомим недоліком цієї технології є відсутність буферизації даних усередині комутаційної матриці.
КОМУТАТОРИ ЗІ СПІЛЬНОЮ ШИНОЮ.
Комутатори зі спільною шиною використовують для зв'язку процесорів портів високошвидкісну шину, яка використовується в режимі поділу часу. Ця архітектура комутаторів на основі універсального процесора, але відрізняється тим, що шина тут пасивна, а активну роль виконують спеціалізовані процесори портів.
КОМУТАТОРИ З ПОДІЛЮВАЛЬНОЮ ПАМ’ЯТТЮ.
Третя базова архітектура взаємодії портів - двохвхідна колективна пам'ять.
Вхідні блоки процесорів портів з'єднуються з входом, що перемикається розділяємої пам'ятті, а вихідні блоки цих же процесорів з'єднуються з виходом пам'яті, що перемикається. Перемиканням входу і виходу розділяємої пам'яті керує менеджер черг вихідних портів. Пам'ять повинна бути досить швидкодіюча для підтримки швидкості перепису даних між N портами комутатора. Застосування загальної буферної пам'яті, гнучко розподіленою менеджером між окремими портами, знижує вимоги до розміру буферної пам'яті процесора порту.

v11
1.Завдання мови SQL. Поняття запиту. Розкрийте поняття кортежу в реляційній моделі даних. 
SQL — декларативна мова програмування для взаємодії користувача з БД, що застосовується для формування запитів, оновлення і керування реляційними БД, створення схеми БД та її модифікації, системи контролю за доступом до БД.
СКЛАД МОВИ SQL:
Мова SQL призначена для маніпулювання даними в реляційних БД, визначення структури БД і для управління правами доступу до даних в багатокористувацькому середовищі.
Тому, в мову SQL в якості складових частин входять:
• мова маніпулювання даними (Data Manipulation Language, DML).
• мова визначення даних (Data Definition Language, DDL).
• мова керування даними (Data Control Language, DCL).
• мова управління транзакціями (Transaction Control Language, TCL).
Data Manipulation Language (DML) - це група операторів для маніпуляції даними. За допомогою цих операторів ми можемо додавати, змінювати, видаляти і вивантажувати дані з бази, тобто маніпулювати ними.
У цю групу входять найпоширеніші оператори мови SQL:
• SELECT - здійснює вибірку даних;
• INSERT - додає нові дані;
• UPDATE - змінює існуючі дані;
• DELETE - видаляє дані.
Data Definition Language (DDL) - це група операторів визначення даних. За допомогою операторів, що входять в цю групу, ми визначаємо структуру БД і працюємо з об'єктами цієї бази, тобто створюємо, змінюємо і видаляємо їх.
У цю групу входять наступні оператори:
• CREATE - використовується для створення об'єктів бази даних;
• ALTER - використовується для зміни об'єктів бази даних;
• DROP - використовується для видалення об'єктів бази даних.
Data Control Language (DCL) - група операторів визначення доступу до даних. Це оператори для управління дозволами, за допомогою них ми можемо дозволяти або забороняти виконання певних операцій над об'єктами БД.
Сюди входять:
• GRANT - надає користувачеві або групі дозволу на певні операції з об'єктом;
• REVOKE - відкликає видані дозволи;
• DENY- задає заборону, маючий пріоритет над вирішенням.
Transaction Control Language (TCL) - група операторів для управління транзакціями. Група операторів TCL призначена для реалізації і управління транзакціями. Сюди можна віднести:
• COMMIT TRANSACTION - застосовує транзакцію;
• ROLLBACK TRANSACTION - відкочується всі зміни, зроблені в контексті поточної транзакції.
Операція вибірки дозволяє отримати всі рядки або частину рядків однієї таблиці:
SELECT * FROM <table_name>
Додаємо нові дані:
INSERT INTO <table_name> default values
Змінюємо існуючі дані:
UPDATE <table_name> SET {column_name | NULL |DEFAULT},…} [{WHERE <predicate>}]
Видаляємо дані:
DELETE FROM <table_name> [WHERE <predicate>]
Створюємо об'єкти БД:
CREATE TABLE <table_name> [(Create_definition,…)] [table_option] [select_statement]
Змінюємо об'єкти БД:
ALTER TABLE <table_name> <alter_spec> [, <alter_spec…>]
Видаляємо об'єкти БД:
DROP TABLE [IF EXISTS] <table_name> [, <table_name>,…] [RESTRICT | CASCADE]
Надаємо користувачеві або групі дозволу на певні операції з об'єктом:
GRANT <privilege_name> ON <object_name> TO {<user_name> |PUBLIC |<role_name>} [WITH GRANT OPTION]
Відкликаємо видані дозволи:
REVOKE <privilege_name> ON <object_name> FROM {<user_name> |PUBLIC |<role_name>}
Задаємо заборону, маючий пріоритет над вирішенням:
DENY <permission> TO <database_principal> [CASCADE] [AS <database_principal>]
Застосовуємо транзакцію:
COMMIT TRANSACTION [ transaction_name | @tran_name_variable ] ] [ WITH ( DELAYED_DURABILITY = { OFF | ON } ) ]
Відкочуємо всі зміни, зроблені в контексті поточної транзакції:
ROLLBACK TRANSACTION [transaction_name | @tran_name_variable | savepoint_name | @savepoint_variable]


КОРТЕЖ - це рядок відношення. Кортежі називаються розширенням, станом або тілом відношення, яке постійно змінюється.
2.Методи комутації кадрів в мережах Ethernet. Сутність, переваги та недоліки “комутації на льоту” та  “комутації з накопиченням”.
У сучасних ЛОМ Ethernet все більш широке вживання знаходять комутатори, що забезпечують багатократне зростання мережної продуктивності, звуження областей розповсюдження широкомовного трафіку, зменшення часу відгуку серверних додатків і інші переваги. Велике число представлених на сучасному ринку комутаторів різних типів і класів затрудняє мережним адміністраторам вибір конкретних пристроїв і моделей. 
У самому загальному випадку комутатор є багатопортовим мостом.
Величина затримки кадрів при проходженні через комутатор і можливості відкидання кадрів, що містять помилки, залежать від методу комутації, що використовується. Більш швидкісні методи комутації не проводять контролю помилок і кадри з некоректними значеннями контрольної суми, пошкоджені в результаті колізій кадри без перешкод проходять через такі комутатори. Відсутність контролю помилок забезпечує зниження затримки при передачі кадрів через комутатор. Інтегральна продуктивність комутатора напряму не залежить від методу комутації, але в результаті обробки помилкових або виникнення блокування продуктивність може істотно знижуватися. Тому виділяють наступні технології комутації , які описані нижче.
КОМУТАЦІЯ З ПРОМІЖНОЮ БУФЕРИЗАЦІЄЮ.
При використовуванні цього методу комутатор повинен прийняти кадр повністю перед тим, як цей кадр буде направлений в інший порт. Для прийнятих кадрів здійснюється обчислення контрольної суми і порівняння отриманого значення з полеМ в прийнятому кадрі. При виявленні невідповідності значень кадр відкидається як помилковий. Час затримки в таких комутаторах росте майже пропорційно розміру кадру, оскільки кожний додатковий байт кадру приводить до зростання часу на буферизацію і обчислення контрольної суми. Перевагою комутаторів такого типу є відкидання помилкових кадрів. Крім того, проміжна буферизація кадрів дозволяє створювати комутатори, інтерфейси яких можуть працювати з різними швидкостями.
БЕЗФРАГМЕНТНА КОМУТАЦІЯ.
Цей метод комутації є розвитком варіанту комутації "на льоту". Основна відмінність між двома методами полягає в тому, що при безфрагментній комутації передача кадру у вихідний порт починається лише після прийому перших 64 байтів кадру. В результаті аналізу цих 64 байт можна знайти більшість помилкових кадрів. Таке рішення дозволяє відкинути більшість помилкових кадрів практично без зростання затримки на обробку в комутаторі. Проте комутатори цього типу також не дозволяють використовувати в одному пристрої інтерфейси, що працюють з різними швидкостями.
ГІБРИДНА КОМУТАЦІЯ.
Для визначення методу комутації стосовно окремо взятого кадру можуть використовуватися достатньо витончені алгоритми. Комутатори цього типу дозволяють скористатися перевагами будь-якого з перерахованих вище методів.
Ще однією особливістю комутаторів є можливість встановлення між двома портами віртуального каналу, що зводить можливість виникнення колізій до нуля. Для того, щоби правильно працювати , при початковому ввімкненні комутатори вивчають МАС адреси пристроїв, які до них підключені і будують таблицю комутації, що значно прискорює їх роботу. 
КОМУТАЦІЯ НА ЛЬОТУ.
При комутації "на льоту" передача кадру у вихідний порт починається практично одразу ж після початку прийому кадру вхідним портом: перевірки контрольної суми і розмірів кадрів не проводиться. Для того, щоб почати передачу кадру комутатору достатньо прийняти адресу одержувача кадру, який дозволяє визначити вихідний по. Час затримки для комутаторів цього типу не залежить від розмірів кадру, оскільки передача кадру у вихідний порт починається відразу після прочитання MAC-адреси одержувача, який має фіксований зсув від початку кадру. До недоліків таких комутаторів відноситься неможливість підтримки інтерфейсів, що працюють з різними швидкостями.
КОМУТАЦІЯ З НАКОПИЧЕННЯМ.
При комутації з накопиченням пропускна здатність мережі не закріплюється на весь час сеансу зв'язку двох абонентів, а представляється їм лише в міру необхідності при появі у них повідомлень для передачі. Такий підхід дозволяє значно підвищити ефективність використання пропускної здатності трактів мережі.
При системі комутації з накопиченням ВП має постійний прямий зв'язок зі своїм вузлами комутації і передає на нього інформацію, а потім ця інформація поетапно передається через вузли комутації іншим абонентам, причому в разі зайнятості вихідних каналів інформації запам'ятовується в вузлах і передається в міру звільнення каналів в потрібному напрямку.

v11p
CREATE DATABASE slushba_kes;
USE slushba_kes;

/* 
zag ----загальна
pl -----площа
*/

CREATE TABLE budivli(
id_bud INT PRIMARY KEY, 
zag_nazva VARCHAR(30), 
zag_pl_bud INT, 
poverhiv INT); 

CREATE TABLE kimnatu(
id_kim INT PRIMARY KEY,
nomer_kim INT,
zag_nazva_kim VARCHAR(30), 
zag_pl_kim INT,
bud_id INT REFERENCES budivli(id_bud));

CREATE TABLE mayno(
id_mayno INT PRIMARY KEY,
kil_stoliv INT,
kil_stiltsiv INT,
kil_shaf INT,
kim_id INT REFERENCES kimnatu(id_kim)); 

INSERT INTO budivli VALUES 
(1,'Учбовий корпус',1200,4),/*("1"-id_будівлі, "Учбовий корпус"-назва будівлі, "1200"-площа будівлі,"3"-кількість поверхів*/
(2,'Казарма першого факультету',700,3),
(3,'Казарма другого факультету',900,3),
(4,'Казарма третього факультету',860,3),
(5,'Столова велика',900,1),
(6,'Столова мала',500,1),
(7,'Столова офіцерська',700,1),
(8,'Спортзал',1000,2),
(9,'КПП 1',200,1),
(10,'КПП 2',100,1);

INSERT INTO kimnatu VALUES 
(1,101,'Аудиторія 101',150,1), /*("1"-id_кімнати, "101"-номер кімнати, "Аудиторія 101"-назва кімнати,"155"-площа кімнати,"1"-це id будівлі до якої привязується кімната*/
(2,102,'Аудиторія 102',140,1),
(3,103,'Аудиторія 103',110,1),
(4,54,'Світлиця',80,2),
(5,74,'Світлиця',90,3),
(6,84,'Світлиця',100,4),
(7,5,'Кухня',200,5),
(8,6,'Кухня',150,6),
(9,6,'Кухня',120,7),
(10,33,'Кабінет начальника',20,8),
(11,2,'Приміщення чергового КПП1',50,9),
(12,3,'Приміщення чергового КПП2',50,10);

INSERT INTO mayno VALUES 
(1,15,32,5,1), /*("1"-id_списку_майна, "15"-столів, "32"-стільця,"5"-шаф,"1"-це id кімнати до якої привязується майно*/
(2,10,22,3,2),
(3,13,28,4,3),
(4,8,16,2,4),
(5,7,20,2,5),
(6,9,20,2,6),
(7,6,8,2,7),
(8,4,5,2,8),
(9,3,4,1,9),
(10,1,3,2,10),
(11,1,2,0,11),
(12,1,2,0,12);

CREATE PROCEDURE ShowAll AS 
SELECT zag_nazva,nomer_kim,kil_stoliv,kil_stiltsiv,kil_shaf from budivli,kimnatu,mayno where bud_id=id_bud AND kim_id=id_kim

EXEC ShowAll;

v12
1.Концептуальне проектування БД та його особливості. Основні оператори DML в СКБД MySQL.
Концептуальна модель – модель предметної області, що складається з переліку взаємопов’язаних понять, що використовуються для опису цієї області, разом з властивостями й характеристиками, класифікацією цих понять, за типами ситуацій, ознаками в даній області і законами протікання процесів в ній.
Розрізняють два головних підходи до моделювання даних при концептуальному проектуванні:
• семантичні моделі;
• об’єктні моделі.
Семантичні моделі головну увагу приділяють структурі даних. Найбільш поширеною семантичною моделлю є модель „сутність – зв’язок” (Entity Relationship model, ER-модель). ER-модель складається із сутностей, зв’язків, атрибутів, доменів атрибутів, ключів. Моделювання даних відображає логічну структуру даних, так само, як блок-схеми алгоритмів відображають логічну структуру програми.
Об’єктні моделі головну увагу приділяють поведінці об’єктів даних і засобам маніпуляції даними. Головне поняття таких моделей  об’єкт, тобто сутність, яка має стан і поведінку. Стан об’єкта визначається сукупністю його атрибутів, а поведінка об’єкта визначається сукупністю операцій специфікованих для нього.
Семантична модель
ER-моделювання являє собою низхідний підхід до проектування БД, який починається з визначення найбільш важливих даних, які називаються сутностями (entities), і зв’язків (relationships) між даними, які повинні бути представлені в моделі. Потім в модель заноситься інформація про властивості сутностей і зв’язків, яка називається атрибутами (attributes), а також всі обмеження, які відносяться до сутностей, зв’язків і атрибутів. ER-модель дає графічне представлення логічних об’єктів і їх відношень в структурі БД. 
Сутність дозволяє моделювати клас однотипних об’єктів. Сутність має унікальне ім’я у межах системи, що моделюється. Оскільки сутність відповідає деякому класу однотипних об’єктів, то передбачається, що в системі існує багато екземплярів даної сутності. Об’єкт, якому відповідає сутність, має набір атрибутів, які характеризують його властивості. При цьому набір атрибутів повинен бути таким, щоби можна було розрізняти конкретні екземпляри сутності.
Атрибути являють собою властивості сутності. Значення кожного  атрибута  вибирають  з  відповідної множини значень, яка включає всі потенційні значення, які можуть бути присвоєні атрибуту. Ця множина значень називається доменом.
Об’єктна модель
Об'єкт являє собою концептуальну модель реального світу, в яку вбудовані представлення даних (атрибути) і їх поведінка (методи). 
Кожен об'єкт має унікальний ідентифікатор OID (Object Identifier, ідентифікатор об’єкта), який не залежить від його атрибутів. Атрибути входять в склад об’єкта і кожен атрибут може посилатися на інший об’єкт. 
Стан об’єкта визначається набором значень, які об’єкт має в даний момент часу. 
Методи реалізують поведінку об’єкта. Методи викликають за допомогою повідомлень. Реалізація методів і представлення даних інкапсульовані, тобто приховані від зовнішніх джерел.
Схожі об’єкти групуються в класи. Клас являє собою колекцію об’єктів зі спільною структурою і поведінкою. Кожен об’єкт являє собою екземпляр класа або екземпляр об’єкта. Класи організовуються в ієрархію класів. 
Об’єкт наслідує атрибути і методи всіх своїх суперкласів.
Data Manipulation Language (DML) - це група операторів для маніпуляції даними. За допомогою цих операторів ми можемо додавати, змінювати, видаляти і вивантажувати дані з бази, тобто маніпулювати ними.
У цю групу входять найпоширеніші оператори мови SQL:
• SELECT - здійснює вибірку даних;
• INSERT - додає нові дані;
• UPDATE - змінює існуючі дані;
• DELETE - видаляє дані.
Операція вибірки дозволяє отримати всі рядки або частину рядків однієї таблиці:
SELECT * FROM <table_name>
Додаємо нові дані:
INSERT INTO <table_name> default values
Змінюємо існуючі дані:
UPDATE <table_name> SET {column_name | NULL |DEFAULT},…} [{WHERE <predicate>}]
Видаляємо дані:
DELETE FROM <table_name> [WHERE <predicate>]

2.Технології створення VLAN: порівняльний аналіз, область застосування.
Це мережа віртуального типу, налаштувати її можна на switch другого рівня. По-іншому вона називається широкомовним доменом.
По суті, VLAN являє собою мітку в кадрі, передану мережею. У неї є ID. Під нього відводиться 12 біт, тобто мітка може мати нумерацію від 0 до 4095.
Важливо: зарезервовані 1-й і останній номери, використовувати їх не можна.
VLAN — прерогатива не робочих станцій, а комутаторів. На портах таких пристроїв зазначено, в якій віртуальній мережі вони знаходяться: весь трафік, що виходить через порт, буде відзначатися міткою — VLANом. Завдяки цьому він надалі зможе йти та через інші інтерфейси switch, що працюють під цією позначкою. При цьому інші порти цей трафік приймати не будуть.
Таким чином, створюється окрема підмережа, яка не може вступати у взаємодію з іншими підмережами без використання комутатора або роутера.
Що дозволяє робити VLAN:
• побудувати мережу з незалежною логічною структурою. Побудова її топології не буде залежити від того, де фізично знаходяться компоненти мережі.
• розбити один такий домен на кілька: трафік широкомовного типу, який належить одному домену, не буде проходити через інший. Це дозволяє менше навантажувати мережеве обладнання.
• захистити мережу від стороннього втручання. Порт свитча зможе ігнорувати та відкидати кадри, які надходять з інших VLAN, причому незалежно від початкового IP.
• групувати ПК, які входять в одну підмережу, і застосовувати політики на всю групу.
• здійснювати маршрутизацію за допомогою використання віртуальних портів.
Порти: теговані та нетеговані
Щоб забезпечити можливість відправки й приймання трафіку, який належить іншій підмережі, портом, його необхідно перевести в стан транка або тегування. У першому випадку роз’єм пропускає трафік всіх VLAN, а в другому — працює з трафіком тільки деяких VLAN.
Варто відзначити, що різному обладнанню можуть знадобитися різні налаштування. Так, деякі пристрої вимагають, щоб на фізичному інтерфейсі було зазначено стан конкретного порту. Для іншого ж обладнання може знадобитися вказати, що певний роз’єм належить тому чи іншому вілану. Якщо ж буде потрібно, щоб кілька VLAN йшли через один порт, то в кожному з них необхідно вказати інтерфейс з тегом.
Як можна використовувати віртуальний LAN
Подібні мітки створюють для об’єднання девайсів, приєднаних до різних switch в одну мережу. Можна частину комп’ютерів згрупувати в один vlan, а частину — в другий. Завдяки цьому ПК в різних доменах будуть функціонувати таким чином, ніби вони під’єднані до одного комутатора. Обладнання, яке входить в різні vlan, розпізнавати один одного не зможе. Це також дає можливість створення гостьової мережі.
Можна виділити чотири головні плюси застосування Virtual LAN:
• можливість гнучкого угрупування девайсів і створення таким чином ізольованої підмережі.
• зниження обсягу широкомовного трафіку: він просто не транслюється між різними підмережами.
• підвищення рівня безпеки та можливостей управління. Для кожної віртуальної підмережі можна застосовувати різні налаштування безпеки та доступу.
• можливість знизити кількість мережевих пристроїв і кабелів для використання, адже для створення нової віртуальної підмережі не потрібно купувати комутатор і прокладати кабель живлення.
v12p
CREATE DATABASE fin_slushba;
USE fin_slushba;

CREATE TABLE posada(
id_pos INT PRIMARY KEY, 
nazva_pos VARCHAR(30), 
oklad_posadu INT); 

CREATE TABLE zvanny(
id_zvan INT PRIMARY KEY,
name_zvan VARCHAR(30),
oklad_zvanny INT);

CREATE TABLE osob_slad(
id_os INT PRIMARY KEY,
PIB VARCHAR(30),
pos_id INT REFERENCES posada(id_pos),
zvan_id INT REFERENCES zvanny(id_zvan)); 

INSERT INTO posada VALUES 
(1,'Командир частини',5000),
(2,'Начальник штабу',4900),
(3,'Заступник з МПЗ',4800),
(4,'Заступник з озброєння',4800),
(5,'Заступник з тилу',4700),
(6,'Командир батальйону',4500),
(7,'Командир роти',4000),
(8,'Командир взводу',3500),
(9,'Старшина роти',3000),
(10,'Командир відділення',2500);

INSERT INTO zvanny VALUES 
(1,'Полковник',5500), 
(2,'Підполковник',4900),
(3,'Майор',4500),
(4,'Капітан',4300),
(5,'Ст.Лейтенант',4000),
(6,'Лейтенант',3600),
(7,'Мол.Лейтенант',3400),
(8,'Прапорщик',3200),
(9,'Сержант',2700),
(10,'Солдат',2300);

INSERT INTO osob_slad VALUES 
(1,'Іванов Іван',1,1),
(2,'Петров Петро',2,2),
(3,'Шевченко Олег',3,2),
(4,'Морозов Микола',4,2),
(5,'Сидоров Данило',5,3),
(6,'Проценко Дмитро',6,3),
(7,'Бурий Олександр',7,4),
(8,'Білий Максим',8,5),
(9,'Фролов Олексій',9,8),
(10,'Комаров Іван',10,9);


CREATE PROCEDURE ShowZP AS
SELECT PIB,name_zvan,nazva_pos,oklad_posadu+oklad_zvanny AS zar_plata
from osob_slad,zvanny,posada where pos_id=id_pos AND zvan_id=id_zvan

EXEC ShowZP;

v13
1.Основні протоколи WEB. Стек протоколів TCP/IP.  Структура HTML документа.
Основні протоколи WEB:
• HTTP (Hyper Text Transfer Protocol)
• HTTPS (HyperText Transfer Protocol Secure)
HTTP  — це прикладний протокол передачі даних у мережі. Наразі його використовують для отримання інформації з веб-сайтів. Протокол HTTP заснований на використанні технології «клієнт-сервер»: клієнт, що відправляє запит, є ініціатором з’єднання; сервер, який отримує запит, виконує його і відправляє клієнту результат.
HTTPS — це розширення протоколу HTTP, що підтримує шифрування за допомогою криптографічних протоколів SSL и TLS.
Різниця між HTTP і HTTPS
Найголовніший плюс HTTPS-з’єднання – його зашифрованность. Вся інформація передається в зашифрованому вигляді, і розкрити ці відомості можуть тільки учасники обміну. Тобто якщо обмін даними за допомогою захищеного з’єднання йде між користувачем і веб-ресурсом, то вся інформація буде мати зашифрований вид. Якщо якась третя особа захоче побачити ці відомості, воно ніяк не зможе отримати їх в початковому вигляді.
Для шифрування інформації використовуються спеціальні ключі. Вони передаються від одного учасника обміну до іншого, і третя особа ніяк не може отримати доступ до цих ключам. 
Захищений протокол, крім простого шифрування даних, може виступати в ролі визначника надійності. У ненадійних ресурсів немає сертифіката. Вони просто не будуть його одержувати з тієї простої причини, що їм нема чого це робити. Якщо сайт хоче викрадати інформацію про користувачів (їх паролі та інші особисті дані), то установка сертифікату зробить цей процес неможливим.
Тому наявність у ресурсу HTTPS-з’єднання і зеленого замочка може говорити про надійність. 
Стек протоколів TCP/IP — набір протоколів мережі Інтернет. 
Стек протоколів TCP/IP ділиться на 4 рівні: прикладний (application), транспортний (transport), міжмережевий (internet) та рівень доступу до середовища передачі.
Прикладний рівень
Протоколи прикладного рівня TCP/IP визначають процедури організації взаємодії прикладних процесів різних мережевих комп'ютерів і форми подання інформації за такої взаємодії. За ознаками взаємодії прикладних процесів виділяють два типи прикладного програмного забезпечення: програма-клієнт та програма-сервер. Серед традиційних послуг, котрі забезпечують протоколи прикладного рівня з сімейства TCP/IP, сьогодні найпопулярнішими є електронна пошта — протоколи SMTP та POP3, передача файлів — FTP та TFTP, емуляція віддаленого терміналу —TELNET.
Транспортний рівень
Протоколи транспортного рівня TCP/IP-моделі надають транспортні послуги прикладним процесам. Основними протоколами транспортного рівня TCP/IP є протокол керування передавання TCP і протокол користувальницьких дейтаграм UDP. Транспортні послуги цих протоколів суттєво відрізняються. Протокол UDP доставляє дейтаграми без установлення з'єднання. При цьому він не гарантує їхнього доставляння. Протокол TCP забезпечує надійне доставляння байтових потоків із попереднім встановленням транспортного дуплексного з'єднання між модулями TCP мережевих комп'ютерів.
Міжмережевий рівень
Протоколи мережевого рівня TCP/IP забезпечують взаємодію мереж різної архітектури. Основним протоколом мережного рівня технології TCP/IP є міжмережевий протокол IP та його допоміжні протоколи: адресний протокол ARP; реверсний адресний протокол RARP (Reverse ARP); протокол діагностичних повідомленьICMP (Internet Control Message Protocol), який надсилає повідомлення вузлам мережі про помилки на маршруті, які виникають при передачі пакетів тощо.
Головне завдання міжмережевого протоколу IP — це маршрутизація пакетів даних між різнотипними комп'ютерними мережами. 
Рівень доступу до середовища передачі (Network Access Layer)
Функції:
• відображення IP-адреси в фізичні адреси мережі;
• інкапсуляція IP-дейтаграм в кадри для передачі по фізичному каналу і передачі кадрів.
HTML документ
<!DOCTYPE html>
<html>
  <head>
     <title>Заголовок документу</title>
  </head>
  <body>
          <h1>Заголовок</h1>
          <p>Зміст документу...</p>
  </body>
</html>
 

2.Типи адрес стеку TCP/IP.  Адреса третього рівня: формат, ієрархічна структура, класи адрес та їх ознаки, технологія формування підмереж. Класова маска. Позакласова маска.
У стеці TCP/IP використовуються три типи адрес: локальні (які також називаються апаратними), IP-адреси й символьні доменні імена.
У термінології TCP/IP під локальною адресою розуміється такий тип адреси, що використовується засобами базової технології для доставки даних у межах підмережі, що є елементом складеної інтермережі. Якщо підмережею інтермережі є локальна мережа, то локальна адреса - це Мас-адреса. Мас-адреса призначається мережевим адаптерам і мережевим інтерфейсам маршрутизаторів. 
IP-адреси являють собою основний тип адрес, на підставі яких мережевий рівень передає пакети між мережами. Ці адреси складаються з 4 байт. IP-адреса призначається адміністратором під час конфігурування комп'ютерів і маршрутизаторів. IP-адреса складається із двох частин: номера мережі й номера вузла. Номер мережі може бути обраний адміністратором довільно, або призначений за рекомендацією спеціального підрозділу Internet, якщо мережа повинна працювати як складова частина Internet. 
Символьні доменні імена. Символьні імена в IP-мережах називаються доменними й будуються по ієрархічній ознаці. Складові повного символьного імені в IP-мережах розділяються крапкою й перераховуються в наступному порядку: спочатку просте ім'я кінцевого вузла, потім ім'я групи вузлів, потім ім'я більшої групи і так до імені домена найвищого рівня.
Адреса третього рівня
Кожен вузол в мережі TCP / IP може бути однозначно ідентифікований IP-рівнем за адресою, який має формат <ідентифікатор мережі, номер вузла>. Для точного визначення вузла завжди використовується повна адреса. Між полями немає поділу. 
Загальний формат IP-адреси:
<Номер мережі, Номер вузла> в форматі xxx. xxx. xxx. xxx
У десятковому записі адреси можуть варіюватися від 0. 0. 0. 0 до 255. 255. 255. 255. За винятком першого, будь-який байт може визначати номер мережі і вузла. Перший байт завжди показує номер мережі.
IP-адреси діляться на п'ять класів: A, B, C, D і E. Класи дозволяють організовувати різну кількість мереж і вузлів в них. A, B і C використовуються для подання адрес мереж і вузлів мережі. Клас D - це спеціальний тип адреси, що використовується для групової розсилки. Клас Е зарезервований в експериментальних цілях.
Визначення класу
Для присвоєння адрес мереж і вузлів використовуються адреси класів A, B і C. Клас D не використовується, а адреси Е ніколи не присвоюються. 
Якщо перший біт першого байта дорівнює 0 - це адреса класу А.
Якщо перший біт дорівнює 1, тоді протокол читає наступний біт. Якщо наступний дорівнює 0 - це адреса класу B. Якщо перший і другий біти рівні 1, а третій біт дорівнює 0 - це адреса класу C. Якщо перший, другий і третій біти рівні 1, адреса належить до класу D і зарезервований для адрес групової розсилки. Адреси класу Е призначені для використання в експериментальних цілях.
Технологія формування підмереж
Підмережею називають окрему IP-мережу класу А, В або С.
В IP-адресах існує частина, що представляє номер мережі, і частина, адресуюча номер хосту в мережі. Таким чином ми отримуємо статичну дворівневу ієрархічну модель адреси. Формування підмереж в IP-мережах є третім рівенем в цій ієрархії, і воно проводиться з використанням мережевих масок. Маскою мережі служить бітова маска, в якій набір бітів відповідає бітам, використовуваним для нумерації IP-мережі, а додаткові біти відповідають номеру підмережі.
Адреси класу А, В і С мають стандартні маски, які задаються з урахуванням максимальної кількості мереж і вузлів в них для кожного класу. Для стандартних класів мереж маски мають таке значення:
• 255.0.0.0 - маска для мережі класу А.
• 255.255.0.0 - маска для мережі класу В.
• 255.255.255.0 - маска для мережі класу С.
Поділ мережевий і вузловий частин IP-адреси полегшує процес створення підмереж на основі масок. Без підмереж номери мереж швидко були б вичерпані. 
При застосуванні масок мережі можна ділити на більш дрібні підмережі шляхом розширення мережевої частини адреси і зменшення вузловий частини. Технологія розбиття мереж на підмережі дозволяє створювати більше число мереж з меншою кількістю хостів в них.
Класова IP адресація - це метод IP-адресації, який не дозволяє раціонально використовувати обмежений ресурс унікальних IP-адрес, тому що неможливо використання різних масок підмереж. У класовому методі адресації використовується фіксована маска підмережі, тому клас мережі завжди можна ідентифікувати по першим бітам.
Безкласова IP адресація - це метод IP-адресації, який дозволяє раціонально управляти простором IP адрес. У безкласовому методі адресації використовуються маски підмережі змінної довжини.
v13p
create database fin_slyshba;
use fin_slyshba;


CREATE TABLE posada(
id_pos INT, 
nazva_pos VARCHAR(30),
PRIMARY KEY (id_pos) 
); 

CREATE TABLE zvanny(
id_zvan INT,
name_zvan VARCHAR(30),
PRIMARY KEY (id_zvan));

CREATE TABLE osob_sklad(
id_os INT,
PIB VARCHAR(30),
rik_nar INT,
nomer_posvid VARCHAR(30),
PRIMARY KEY (id_os),
pos_id INT REFERENCES posada(id_pos),
zvan_id INT REFERENCES zvanny(id_zvan)); 

INSERT INTO posada VALUES 
(1,'Командир частини'),
(2,'Начальник штабу'),
(3,'Заступник з МПЗ'),
(4,'Заступник з озброєння'),
(5,'Заступник з тилу'),
(6,'Командир батальйону'),
(7,'Командир роти'),
(8,'Командир взводу'),
(9,'Старшина роти'),
(10,'Командир відділення');

INSERT INTO zvanny VALUES 
(1,'Полковник'), 
(2,'Підполковник'),
(3,'Майор'),
(4,'Капітан'),
(5,'Ст.Лейтенант'),
(6,'Лейтенант'),
(7,'Мол.Лейтенант'),
(8,'Прапорщик'),
(9,'Сержант'),
(10,'Солдат');

INSERT INTO osob_sklad VALUES 
(1,'Іванов Іван',1972,'АА 315683',1,1),
(2,'Петров Петро',1974,'СВ 867352',2,2),
(3,'Шевченко Олег',1975,'КВ 34747',3,2),
(4,'Морозов Микола',1973,'МА 943721',4,2),
(5,'Сидоров Данило',1980,'ТТ 123456',5,3),
(6,'Проценко Дмитро',1989,'ОР 654321',6,3),
(7,'Бурий Олександр',1990,'АВ 645287',7,4),
(8,'Білий Максим',1977,'УК 878787',8,5),
(9,'Фролов Олексій',1994,'ПМ 473561',9,8),
(10,'Комаров Іван',1991,'ВВ 987567',10,9);


CREATE PROCEDURE showOS()
SELECT PIB,rik_nar,name_zvan,nazva_pos,nomer_posvid
from osob_sklad,zvanny,posada where pos_id=id_pos AND zvan_id=id_zvan;

CALL showOS();



v14
Білет №14
1.Робота з зображеннями та таблицями в HTML. Основні теги та їх властивості. 
Для додавання зображення на сторінку використовується тег <img>. Це одиночний тег, йому не потрібен закриваючий. Усередині цього тега містяться атрибути.
Атрибут src вказує шлях до файлу. Якщо зображення лежить у на комп'ютері або на сервері - використовується відносне посилання. Якщо зображення з мережі, тоді потрібне абсолютне посилання.
<img src = "шлях до файлу">
Атрибут alt вказує на текст, який побачить користувач, якщо зображення не завантажиться. 
<img src = "шлях до файлу" alt = "назва зображення">
Також можна встановити висоту і ширину зображенню, якщо оригінальне зображення більше, ніж потрібно.
У HTML5 це рекомендується робити за допомогою CSS або атрибута style:
<img src = "шлях до файлу.jpg"
alt = "назва зображення" style = "width: 30%; height: 30%;">
Також ширину і висоту можна задавати в пікселях.

Основні теги таблиці
Таблиця складається з декількох обов'язкових тегів:
• тег <table> - це тег, який говорить браузеру, що всередині нього буде таблиця
• тег <tr> - позначає рядок
• тег <td> - позначає комірку. Саме в цей тег закладається все, з чого складатиметься таблиця - текст, зображення, списки, кнопки або навіть інші таблиці.
Щоб назвати таблицю, використовується тег <caption>.
У більшості випадків перший рядок таблиці описує ті значення, які підуть в колонках.
У HTML для цього є спеціальний тег <th> . Він прописується замість <td> в першому рядку.
Атрибут rowspan об'єднує осередки у сусідніх рядів (тобто по вертикалі).
Атрибут colspan об'єднує осередки у сусідніх колонок (тобто по горизонталі).

Основні теги html
<html> </ html> вказує програмі перегляду сторінок що це HTML документ.
<head> </ head> визначає місце, де розміщується різна інформація, що не відображається в тілі документа. Тут розташовується тег назви документа та теги для пошукових машин.
<body> </ body> визначає видиму частину документа.
2.Загальна характеристика архітектури Ethernet (топологія, середовище передачі,  метод доступу, формат кадру, кількісні показники).
Ethernet – архітектура мереж, що грунтується на логічній топології шини, з розподіленим середовищем передавання, методом доступу до середовища передавання CSMA/CD, описана стандартом IEEE802.3. За фізичною реалізацією розрізняють:
• 10Base5 – Thick ("товстий") Ethernet; 
• 10Base2 – Thin ("тонкий") Ethernet; 
• 10BaseT – Twisted–pair Ethernet (Ethernet на витій парі); 
• 10Broad36 – мережа на широкосмуговому 75–Омному коаксіальному кабелі; 
• 10BaseF – кілька варіантів мережі на оптоволоконному кабелі; 
• 100BaseT – стандарти FastEthernet на витій парі (100BaseT4, 100BaseTX). 
Перший елемент в умовному позначенні архітектури – швидкість передавання в Mбіт/с; другий елемент позначає спосіб передавання: Base – пряме немодульоване передавання, Broad – використання широкосмугового кабелю з частотним ущільненням каналів; третій елемент – середовище передавання (T – вита пара, F – оптоволокно) або довжина сегмента кабелю в сотнях метрів (сучасні мережні адаптери дають змогу збільшувати довжину сегмента, наприклад для 10Base2, до 250-300 метрів).
Існує кілька стандартів формату кадру Ethernet. На практиці в обладнанні Ethernet використовується тільки один формат кадру, а саме кадр Ethernet DIX, який іноді називають кадром Ethernet II за номером останнього стандарту DIX.
v14p
CREATE DATABASE rech_slushba;

USE rech_slushba;

CREATE TABLE forma_polova(
id_forma INT PRIMARY KEY, 
rozm_formu VARCHAR(30),
kilk_formu INT,
sklad VARCHAR(30)
); 

CREATE TABLE berci_demi(
id_berc INT PRIMARY KEY, 
rozm_berc VARCHAR(30),
kilk_berc INT,
sklad VARCHAR(30)
);

CREATE TABLE osob_sklad(
id_os INT PRIMARY KEY,
PIB VARCHAR(30),
roz_formu float,
roz_berc float,
forma_id INT REFERENCES forma_polova(id_forma),
berci_id INT REFERENCES berci_demi(id_berc)
); 

INSERT INTO forma_polova VALUES 
(1,'Форма польва 44.3',2,'Склад №1'), 
(2,'Форма польва 44.4',3,'Склад №2'),
(3,'Форма польва 46.2',4,'Склад №1'),
(4,'Форма польва 46.3',1,'Склад №2'),
(5,'Форма польва 46.4',0,'Склад №1'),
(6,'Форма польва 48.3',0,'Склад №2'),
(7,'Форма польва 48.4',0,'Склад №1'),
(8,'Форма польва 48.5',0,'Склад №2'),
(9,'Форма польва 50.3',0,'Склад №1'),
(10,'Форма польва 50.4',0,'Склад №2')
;

INSERT INTO berci_demi VALUES 
(1,'Берци демісезонні 37',2,'Склад №1'),
(2,'Берци демісезонні 38',2,'Склад №2'), 
(3,'Берци демісезонні 39',3,'Склад №1'), 
(4,'Берци демісезонні 40',1,'Склад №2'), 
(5,'Берци демісезонні 41',2,'Склад №1'), 
(6,'Берци демісезонні 42',0,'Склад №2'), 
(7,'Берци демісезонні 43',0,'Склад №1'), 
(8,'Берци демісезонні 44',0,'Склад №2'), 
(9,'Берци демісезонні 45',0,'Склад №1'), 
(10,'Берци демісезонні 46',0,'Склад №2')
;

INSERT INTO osob_sklad VALUES 
(1,'Іванов Іван',44.3,37,1,1),
(2,'Петров Петро',44.3,37,1,1),
(3,'Шевченко Олег',44.4,38,2,2),
(4,'Морозов Микола',44.4,38,2,2),
(5,'Сидоров Данило',44.4,39,2,3),
(6,'Проценко Дмитро',46.2,39,3,3),
(7,'Бурий Олександр',46.2,39,3,3),
(8,'Білий Максим',46.2,40,3,4),
(9,'Фролов Олексій',46.2,41,3,5),
(10,'Комаров Іван',46.3,41,4,5);

GO
CREATE TRIGGER Mayno_UPDATE /*Створюємо тригер з назвою ... */
ON osob_sklad /* Який буде моніторити таблицю OSOB_SKLAD*/ 
AFTER INSERT /*Якщо добавиться новий запис тобто в/c*/
AS
BEGIN
DECLARE @forma_os INT /*Оголошуємо змінну @forma_os з типом даних INT яка буде відповідати за розмір форми */
DECLARE @berci_os INT /*Оголошуємо змінну @berci_os з типом даних INT яка буде відповідати за розмір берц */
SELECT @forma_os =(SELECT forma_id FROM INSERTED) /*Цій змінній присвоюється значення нового запису про розмір форми в таблиці */
SELECT @berci_os =(SELECT berci_id FROM INSERTED) /*Цій змінній присвоюється значення нового запису про розмір берц в таблиці */
UPDATE forma_polova SET kilk_formu = kilk_formu + 1 where id_forma = @forma_os /*Обновляєм записи в таблиці ФОРМИ добавляємо до к-ті форм +1 по id який передався через змінну*/
UPDATE berci_demi SET kilk_berc = kilk_berc + 1 where id_berc = @berci_os /*Обновляєм записи в таблиці ФОРМИ добавляємо до к-ті берц +1 по id який передався через змінну*/
END

INSERT INTO osob_sklad VALUES 
(11,'Коваленко Андрій',50.4,46,10,9);/* При добавленні нового запису в таблицю ОС автоматично добавляється +1 у відповідний розмір в таблиці берць і форми*/

SELECT * FROM forma_polova; /*в таблиці форма під 10 айдішніком буде 1*/

SELECT * FROM berci_demi;/*в таблиці берць +1 буде під 9 айдішником*/

/*Такий самий тригер тільки на видалення */
GO
CREATE TRIGGER Mayno_DELETE
ON osob_sklad 
AFTER DELETE 
AS
BEGIN
DECLARE @forma_os INT
DECLARE @berci_os INT
SELECT @forma_os =(SELECT forma_id FROM DELETED) 
SELECT @berci_os =(SELECT berci_id FROM DELETED)
UPDATE forma_polova SET kilk_formu = kilk_formu - 1 where id_forma = @forma_os 
UPDATE berci_demi SET kilk_berc = kilk_berc - 1 where id_berc = @berci_os 
END

DELETE FROM osob_sklad WHERE id_os=11;

SELECT * FROM berci_demi;

SELECT * FROM forma_polova;
/////////////////////////////
v15
1.	Принципи роботи AJAX. Get-запити. Метод get. 

Принцип роботи
AJAX базується на технології звернення до сервера без перезавантаження сторінки (XTMLHttpRequest, створення дочірніх фреймів або тега script) або використанні DHTML, що дозволяє динамічно змінювати вміст. Формат передачі даних - XML або JSON. AJAX можна реалізувати в різних мовах програмування: PHP, Ruby on Rails, ASP.NET і інших. У коді web-сторінок широко використовується JavaScript для прозорого обміну даними клієнта з сервером. Користувачі взаємодіють зі стандартними HTML елементами, динамічну поведінку яких описується на JavaScript.
Переваги
Для просування сайту застосування AJAX має ряд переваг:
•	економія трафіку користувача (замість оновлення всієї сторінки, завантажується її невелика змінилася частина);
•	зниження навантаження на сервер. Наприклад, на сторінці особистих повідомлень форуму при виділенні користувачем прочитаних листів сервер вносить зміни в БД і відправляє скрипту клієнта відповідь про виконання операції без повторного створення сторінки і її передачі;
•	прискорення реагування інтерфейсу на команди користувача.

Недоліки
При пошукової оптимізації сайту враховують такі недоліки AJAX:
•	не завжди можлива інтеграція зі стандартним набором інструментів браузера. Так як інтернет-оглядачі не реєструють в історії переходи по сторінках, не можна скористатися кнопкою «Назад». У деяких випадках немає можливості додати в закладки потрібний матеріал;
•	контент, що завантажується динамічно, не доступний пошуковим системам, тому необхідно забезпечити альтернативний доступ до вмісту ресурсу;
•	неправильний облік статистики переміщення користувача по сайту;
•	ускладнення контролю цілісності типів і форматів, так як процеси форматування даних частково переносяться на сторону клієнта;
•	в браузері користувача повинен бути включений JavaScript.
Альтернативою AJAX виступають Java-аплети, JavaFX, технології ActionScript 3, Flash Remoting, Adobe Flex, складові технологічну основу Rich Internet Applications від Macromedia, і Silverlight від корпорації Microsoft.

GET-запити. Метод get.
Метод get здійснює GET-запит до сервера, тобто всі дані запиту передаються в рядку запиту. Він приймає такі параметри:
•	url: обов'язковий параметр, який містить адресу ресурсу, до якого буде звертатися запит
•	data: необов'язковий параметр, що містить простий об'єкт javascript або рядок, які будуть відправлені на сервер разом із запитом
•	success (data, textStatus, jqXHR): необов'язковий параметр - функція зворотного виклику, яка буде виконуватися при успішному виконанні запиту. Вона може приймати три параметра: data - дані, отримані з сервера, textStatus - - статус запиту та jqXHR - спеціальний об'єкт jQuery, який представляє розширений варіант об'єкта XMLHttpRequest.
•	dataType: необов'язковий параметр, що містить тип даних у вигляді рядка, наприклад, "xml" або "json"
На виході метод get повертає об'єкт jqXHR, який буде інкапсулювати дані запиту.

2.	Структуровані кабельні системи (СКС). Стандарти, структура, реалізація СКС.
Основна ідея концепції СКС полягає в наступному – структурована кабельна система (СКС) дозволяє використовувати єдиний підхід при створенні комп'ютерних, телефонних мереж, мереж пожежної та охоронної сигналізації шляхом об'єднання їх у єдину систему, керовану з єдиного центру. Це лише загальний опис концепції СКС, на жаль жоден із діючих нині стандартів не дає чіткого визначення терміна «СКС», тому розглянувши складові частини терміну «Структурована Кабельна Система», можна вивести подібне визначення.
 Термін «система» – надто розповсюджений й найчастіше має наступне тлумачення. Система – це сукупність об'єктів або елементів пов'язаних між собою, які взаємодіють один з одним за певними правилами таким чином, що формується єдиний складний об'єкт. Найчастіше системи, які призначені для виконання спеціальних функцій, містять у собі компоненти, що можуть замінятися аналогічними або бути взаємозамінними всередині системи.                               Термін «кабельна». Кабельна система – це система, елементами якої виступають кабельні компоненти. Під кабельними компонентами прийнято розуміти не тільки самі кабелі, але й все пасивне комутаційне обладнання, що служить для з'єднання двох активних мережних пристроїв (розетки, з’єднувальні шнури, комутаційні панелі й т. ін.).                                                                           
Термін «структурована». У загальному випадку структура – це набір взаємозалежних та взаємопов’язаних складових частин. З одного боку структурована означає спроможність системи підтримувати різні типи застосувань (передача даних, голосу, відео), з іншого – можливість використання обладнання від різних виробників і реалізацію мультимедійного середовища (середовища, в якому використовується кілька типів середовищ передавання – вита пара, оптичне волокно ). Крім того термін «структурована» має на увазі те, що існує певна архітектура і топологія, які будуються на базі певних принципів. 
Таким чином, розглянувши три складові терміна «Структурована Кабельна Система (СКС)» можна дати визначення самій СКС. Під СКС можна розуміти – комунікаційну систему для з'єднання різних типів обладнання від різних виробників в обмеженій області, з використанням фізичного середовища передавання, що дозволяє передавати інформацію від різних застосувань, з необхідною швидкістю та мінімальною ймовірністю помилки, яка створена за певними принципами. 
v15p
create database RAO;
use RAO;
ALTER DATABASE RAO COLLATE Cyrillic_General_CI_AS;

CREATE TABLE OSOBY 
( id_osoby INT PRIMARY KEY, 
name_osoby VARCHAR(50), 
posada_osoby VARCHAR(30));

INSERT INTO OSOBY
(id_osoby, name_osoby, posada_osoby) 
VALUES 
(1,'Іванов Іван Іванович', 'Заступник НІ з озброєння'), 
(2,'Фарбей Артур Русланович', 'Начальник 26 курсу'), 
(3,'Влох Сервгій Володимирович', 'Начальник 28 курсу'),
(4,'Голуб Олександр Олександрович','Начальник 25 курсу'),
(5,'Яшник Владислав Олегович','Начальник 27 курсу'),
(6,'Бондарук Тарас Іванович','Начальник 20 курсу'),
(7,'Стозуб Іван Петрович','Начальник 16 курсу'),
(8,'Тислів Володимир Володимирович','Начальник 15 курсу'),
(9,'Лазаренко Євген Сергійович','Начальник 36 курсу'),
(10,'Степанов Микита Олександрович','Начальник 30 курсу');

SELECT * FROM OSOBY

CREATE TABLE PIDROZDIL 
(id_pidrozdil INT PRIMARY KEY, 
name_pidrozdil VARCHAR(20), 
commandyr_pidrozdil INT,
wpn_count INT);

INSERT INTO PIDROZDIL
(id_pidrozdil, name_pidrozdil, commandyr_pidrozdil,wpn_count)
VALUES
(1,'26 курс',2,2),
(2,'28 курс',3,1),
(3,'25 курс',4,3),
(4,'27 курс',5,1),
(5,'20',6,1),
(6,'16',7,1),
(7,'15',8,1),
(8,'36',9,0),
(9,'30',10,0),
(10,'Командування',1,0);

CREATE TABLE ZBROYA
(id_wpn INT PRIMARY KEY,
name_wpn VARCHAR(20),
komplekt VARCHAR(10),
id_pidrozdil INT);

INSERT INTO ZBROYA VALUES
(10001,'AK-74','повний',1),
(10002,'AK-74','повний',1),
(10003,'AK-74','неповний',2),
(50507,'РПК','повний',3),
(79651,'РПК','повний',3),
(26548,'РПК','повний',3),
(32159,'ПМ','повний',4),
(54329,'ПМ','повний',5),
(99845,'СВД','неповний',6),
(65426,'СВД','неповний',7);

ALTER TABLE PIDROZDIL ADD FOREIGN KEY (commandyr_pidrozdil) REFERENCES OSOBY(id_osoby);
ALTER TABLE ZBROYA ADD FOREIGN KEY (id_pidrozdil) REFERENCES PIDROZDIL(id_pidrozdil);

GO
CREATE TRIGGER kilkist_zbroi
ON ZBROYA
AFTER INSERT
AS
BEGIN
DECLARE @kist_zbr INT
SELECT @kist_zbr =(SELECT id_pidrozdil FROM INSERTED) 
UPDATE PIDROZDIL SET wpn_count = wpn_count +1 WHERE id_pidrozdil = @kist_zbr
END

INSERT INTO ZBROYA VALUES
(8888,'AK-74','повний',10);

SELECT * FROM PIDROZDIL;
///////////////////////////
v16
16 білет

1.	Базові поняття REST. POST-запити. Метод post.
REST
(REpresentational State Transfer) - це архітектура, тобто принципи побудови розподілених гіпермедіа систем, того що іншими словами називається World Wide Web, включаючи універсальні способи обробки і передачі станів ресурсів по HTTP
REST на сьогоднішній день практично витіснив всі інші підходи, в тому числі дизайн заснований на SOAP і WSDL.
Що нам дає REST підхід:
•	Масштабованість взаємодії компонентів системи (додатки)
•	спільність інтерфейсів
•	Незалежне впровадження компонентів
•	Проміжні компоненти, що знижують затримку, які посилюють безпеку
Коли використовувати REST?
• Коли є обмеження пропускної здатності з'єднання
• Якщо необхідно кешувати запити
• Якщо система передбачає значне масштабування
• У сервісах, що використовують AJAX

Переваги REST: 

•	Відсутність додаткових внутрішніх прошарків, що означає передачу даних в тому ж вигляді, що і самі дані. Тобто дані не обертаються в XML, як це робить SOAP і XML-RPC, не використовується AMF, як це робить Flash і т.д. Просто віддаються самі дані. 
•	Кожна одиниця інформації (ресурс) однозначно визначається URL - це значить, що URL по суті є первинним ключем для одиниці даних. Причому абсолютно не має значення, в якому форматі знаходяться дані за адресою - це може бути і HTML, і jpeg, і документ Microsoft Word.

HTTP метод POST запит найбільш часто використовується для створення нових ресурсів. На практиці він використовується для створення вкладених ресурсів. Іншими словами, при створенні нового ресурсу, POST запит відправляється до батьківського ресурсу і, таким чином, сервіс бере на себе відповідальність на встановлення зв'язку створюваного ресурсу з батьківським ресурсом, призначення нового ресурсу ID і т.п. При успішному створенні ресурсу повертається HTTP код 201, а також в заголовку `Location` передається адреса створеного ресурсу. POST не є безпечним запитом. В результаті виконання ідентичних POST запитів надаються сильно схожі, але не ідентичні дані.
2.	Документування та адміністрування СКС. Тестування СКС. Сертифікація  та гарантії на СКС.
Документування кабельних ліній СКС Для документування всіх кабельних ліній мають бути виконані записи в кабельному журналі. Кожен запис має містити мінімум наступну інформацію: ідентифікатори точок термінування та місцезнаходження їх на об’єкті з обох сторін, тип кабелю, довжину. 
Під адмініструванням СКС у загальному випадку розуміють способи й
засоби управління цією системою протягом усього строку її експлуатації.
Правильне адміністрування СКС забезпечує її безперебійну та якісну роботу,
знижує час відновлення працездатності у випадку аварій і т. ін. Завдяки даній
підсистемі обслуговуючий персонал СКС має можливість підтримувати СКС у
робочому стані й оперативно реагувати на аварійні ситуації. Підсистема
адміністрування дає можливість:
•	 чітко й швидко визначати точки термінування кабельних трас будь-
•	якого рівня;
•	 чітко й швидко визначати маршрут (шлях) проходження кабельної
•	траси;
•	 чітко й швидко визначати необхідний порт комутаційної панелі або
•	інформаційної розетки;
•	 безпомилково виконувати комутацію;
•	 відзначати зроблені зміни в процесі експлуатації СКС.

При тестуванні СКС необхідно вимірювати досить велику кількість
параметрів, які діляться на три групи:
•	обов'язкові – дані параметри обов'язкові до вимірів, а їхні значення
вимірюються за будь-якого виду вимірів;
•	не обов'язкові (інформаційні) – дані параметри вимірюються за
необхідності або на вимогу замовника;
•	розрахункові – дані параметри не вимірюються, а розраховуються
на базі інших вимірюваних параметрів.
Результати всіх проведених тестів і вимірів в обов'язковому порядку
фіксуються й заносяться в базу даних адміністративної підсистеми СКС.

Сертифікація  та гарантії на СКС.
Гарантійні випадки в СКС досить рідкісні і здається, що сертифікат не потрібен власнику СКС. 
Сертифікат є підтвердженням того, що інсталятор проведе обов'язкове тестування кабельних ліній і перевірить їх на відповідність вимогам кабельних стандартів або на відповідність вимогам класу, виконає проект згідно з вимогами виробника СКС і не встановить пасивні компоненти невідомого походження і сумнівної якості.
v16p
create database avto;
use avto;

CREATE TABLE OSOBY 
( id_osoby INT PRIMARY KEY, 
name_osoby VARCHAR(50), 
category VARCHAR(30));

INSERT INTO OSOBY
(id_osoby, name_osoby, category) 
VALUES 
(1,'Іванов Іван Іванович', 'D,B,C'), 
(2,'Фарбей Артур Русланович', 'C'), 
(3,'Влох Сервгій Володимирович', 'D,C'),
(4,'Голуб Олександр Олександрович','C'),
(5,'Яшник Владислав Олегович','A,B,C'),
(6,'Бондарук Тарас Іванович','D,C'),
(7,'Стозуб Іван Петрович','B,C'),
(8,'Тислів Володимир Володимирович','D,C'),
(9,'Лазаренко Євген Сергійович','C,D'),
(10,'Степанов Микита Олександрович','A,B,C,D');

CREATE TABLE BOX 
(id_box INT PRIMARY KEY, 
name_box VARCHAR(20), 
car_count INT);

INSERT INTO BOX
(id_box,name_box,car_count)
VALUES
(1,'БОКС №1',2),
(2,'БОКС №2',1),
(3,'БОКС №3',3),
(4,'БОКС №4',1),
(5,'БОКС №5',1),
(6,'БОКС №6',1),
(7,'БОКС №7',1),
(8,'БОКС №8',0),
(9,'БОКС №9',0),
(10,'БОКС №10',0);

CREATE TABLE AVTO
(id_car INT PRIMARY KEY,
name_car VARCHAR(20),
id_box INT,
id_osoby INT);

INSERT INTO AVTO VALUES
(10001,'ГАЗ-66',1,1),
(10002,'ВАЗ-131',1,2),
(10003,'ВАЗ-131',2,3),
(50507,'ВАЗ-66',3,4),
(79651,'КОЗАК',3,5),
(26548,'КОЗАК',3,6),
(32159,'ГАЗ-66',4,7),
(54329,'КРАЗ',5,8),
(99845,'УРАЛ',6,9),
(65426,'УРАЛ',7,10);

ALTER TABLE AVTO ADD FOREIGN KEY (id_box) REFERENCES BOX(id_box);
ALTER TABLE AVTO ADD FOREIGN KEY (id_osoby) REFERENCES OSOBY(id_osoby);



DELIMITER $$

CREATE TRIGGER car_count
AFTER INSERT 
ON AVTO for each row
BEGIN 
SELECT COUNT(id_car) FROM AVTO WHERE id_box=NEW.id_box INTO @car_count;
UPDATE BOX SET BOX.car_count = @car_count WHERE BOX.id_box=NEW.id_box;
END
$$
DELIMITER ;

DROP trigger car_count;

INSERT INTO AVTO VALUES
(77778,'ГАЗ-66',10,1);

SELECT * FROM BOX;

/////////////////////////////
v17
1.	Сутність концептуального проектування БД. ER-моделювання. Представлення сутностей, атрибутів та зв’язків в ER-моделях.

У процесі концептуального проектування будується інфологічна модель бази даних. Для цього необхідно виділити всі об'єкти БД, зазначити їхні характеристики (атрибути) і встановити зв'язки між об'єктами.
Інфологічний рівень – це інформаційно-логічну модель (ІЛМ) предметної області (ПО), в якій виключена надмірність даних і відображені інформаційні особливості об'єкта управління, без урахування особливостей і специфіки конкретної СУБД.
Мета інфологічного проектування – створити структуровану інформаційну модель ПО, для якої розроблятиметься БД. Інфологічну модель зручно подавати у вигляді так званої ER-діаграми (Entity – Relationship або Сутність – Зв'язок).

ER-модель (Entity-relationship model або Entity-relationship diagram) – це семантична модель даних, яка призначена для спрощення процесу проектування бази даних. З ER-моделі можуть бути породжені всі види баз даних: реляційні, ієрархічні, мережні, об’єктні. В основі ER-моделі лежать поняття “сутність”, “зв’язок” та “атрибут”.
Для великих баз даних побудова ER-моделі дозволяє уникнути помилок проектування, які надзвичайно важко виправляти, особливо, якщо база даних вже експлуатується чи на стадії тестування. Помилки в розробці структури бази даних може призвести до перебудови коду програмного забезпечення, що керує цією базою даних. У результаті час, кошти та людські ресурси будуть використані неефективно.
ER-модель – це представлення бази даних у вигляді наочних графічних діаграм. ER-модель візуалізує процес, що визначає деяку предметну область. Діаграма “сутність-зв’язок” – це діаграма, яка представляє в графічному вигляді сутності, атрибути і зв’язки.
ER-модель – це тільки концептуальний рівень моделювання. ER-модель не містить деталей реалізації. Для тієї самої ER-моделі деталі її реалізації можуть відрізнятися.

Модель сутність-зв'язок є результатом систематичного процесу, який описує та визначає деяку предметну область. Вона не визначає сам процес, а лише візуалізує його. Дані представлені у вигляді компонентів (сутностей), які пов'язані між собою певними зв'язками, які виражають залежності і вимоги між ними, такі як: одна будівля може бути розділена на нуль або більше квартир, але одна квартира може бути розташована лише в одній будівлі. Сутності можуть мати різні властивості (атрибути), які характеризують їх. Діаграми, створені для представлення цих сутностей, атрибутів і зв'язків графічно, називають сутність-зв'язок діаграмами.
ER-модель зазвичай реалізується в вигляді баз даних. У разі реляційної бази даних, в якій зберігаються дані в таблицях, кожен рядок кожної таблиці являє собою один екземпляр сутності. Деякі поля даних в цих таблицях вказують на індекси в інших таблицях. Такі поля є покажчиками фізичної реалізації зв'язків між сутностями.
2.	Маршрутизація в мережах. Класифікація та стислий аналіз протоколів маршрутизації.
Маршрутиза́ція — процес визначення маршруту прямування інформації між мережами. Маршрутизатор (або роутер від англ. router) приймає рішення, що базується на IP-адресі отримувача пакету. Для того, щоб переслати пакет далі, всі пристрої на шляху слідування використовують IP-адресу отримувача. Для прийняття правильного рішення маршрутизатор має знати напрямки і маршрути до віддалених мереж.
Є два типи маршрутизації:
Статична маршрутизація — маршрути задаються вручну адміністратором.
Динамічна маршрутизація — маршрути обчислюються автоматично за допомогою протоколів динамічної маршрутизації — RIP, OSPF, EIGRP, IS-IS, BGP, HSRP та ін, які отримують інформацію про топологію і стан каналів зв'язку від інших маршрутизаторів у мережі.

Протоколи маршрутизації призначені для автоматичної побудови таблиць маршрутизації (ТМ), на основі яких виконується переміщення пакетів. Такі таблиці містять дані яких достатньо для прийняття рішення для пересилання будь-якого пакета, що надійшов до маршрутизатора. Вміст таблиці залежить від технології складеної мережі.

Характеристика основних протоколів маршрутизації 
1) Одним з найбільш поширених протоколів маршрутизації на основі вектора відстаней, є протокол RIP (Routing Information Protocol). Основні характеристики протоколу RIP: 
•	дистанційно-векторний протокол маршрутизації; метрика - число переходів; 
•	максимальне число переходів - 15; 
•	широкомовна розсилка маршрутизації за замовчуванням - раз в 30 секунд. 

RIP призначений для роботи з мережами середнього розміру, що використовують однорідну технологію. Практично використання RIP обмежена мережами, найдовший шлях якого не перевищує 15 стадій.
2) Закритий дистанційно-векторний протокол IGRP компанії Cisco Systems був спроектований для усунення ряду недоліків протоколу RIP, і мав на меті забезпечити кращу підтримку великих мереж (до 255 маршрутизаторів), які містять канали зв'язку з відмінними характеристиками смуги пропускання і величини затримки. Протокол використовує комбіновану метрику, яка включає затримку, смугу пропускання, надійність і завантаженість маршруту. Вагові коефіцієнти, що визначають внесок цих характеристик в результуючу метрику, задаються користувачем, забезпечуючи гнучку адаптацію до його конкретним завданням.
3) Вдосконаленим протоколом маршрутизації на базі вектора відстаней є протокол EIGRP. Він був розроблений компанією Cisco Systems, отже, часто використовується на обладнанні цієї компанії. Протокол має наступні якості. 1. Більш швидка збіжність в порівнянні з іншими протоколами на базі вектора відстаней, яка досягається завдяки алгоритму DUAL (Diffusing Update Algorithm). Алгоритм становить таблицю 83 топологій, в якій зазначено два кращих шляху до мережі призначення (основний і резервний). На обох цих маршрутах не виникають петлі. 
•	Зниження споживання смуги пропускання досягається за рахунок того, що при будь-яких зміни в мережі, алгоритм DUAL відправляє тільки нові оновлення, а не всю таблицю маршрутизації. 
•	Підтримка декількох протоколів мережевого рівня (IP, IPX, AppleTalk). 
•	Безкласовий протокол маршрутизації. 
•	Використання багатоадресної (224.0.0.10) та одноадресної розсилки, замість широкомовної. Завдяки цьому оновленню маршрутизації не впливають непотрібні маршрутизатори.

4) Одним з поширених протоколів на основі стану каналу є протокол OSPF. Це безкласовий протокол маршрутизації. Технологія роботи протоколу полягає у відстеженні стану каналів і пошуку найкоротших шляхів (Shortest Path First - SPF). Протокол підтримує складну топологічну базу даних. Якщо протоколи на базі вектора відстаней не містять інформацію про віддалених мережах, то протоколи на основі стану каналу підтримують всю інформацію про видалені маршрутизаторах і їх з'єднаннях. Стан каналу в цьому протоколі має на увазі опис інтерфейсу (наприклад, IPадреса, маска, тип мережі і т.п.) і його відношення з сусідніми маршрутизаторами

5) Протокол IS-IS заснований на алгоритмі стану каналів зв'язку і є попередником OSPF. У протоколі обміну даними між проміжними системами ISIS (Integrated Intermediate System-to-intermediate System) використовується той же принцип маршрутизації станом каналів, що і в протоколі OSPF. Обидва ці протоколу відносяться до класу протоколів IGP (Interior Gateway Protocol) і їх головна відмітна особливість - постійно проводиться пошук найкоротшого шляху. Це основна властивість є одночасно як перевагою, так і не достатком. Для передачі даних між двома кінцевими пунктами використовується найкоротший на даний момент маршрут. Але при цьому, для обміну між маршрутизаторами службовою інформацією, доводиться вдаватися до лавинної розсилці пакетів (flooding). Такий процес необхідний для того, щоб кожен маршрутизатор, який є сусіднім до даного, прийнявши чергове повідомлення про зміну стану каналів і оновивши свої таблиці маршрутизації, переслав його далі.

6) Протокол BGP розроблявся як зовнішній для організації маршрутизації між автономними системами в глобальній мережі Internet (максимальне число маршрутизаторів 65534 між AS). В даний час в Internet використовується 4-я версія протоколу BGP-4. Хоча протокол відноситься до зовнішніх протоколів маршрутизації, його іноді застосовують і для внутрішньої маршрутизації. BGP є протоколом, що орієнтується на вектор відстані.
v17p
create database ZVYAZOK;
use ZVYAZOK;
ALTER DATABASE ZVYAZOK COLLATE Cyrillic_General_CI_AS;

CREATE TABLE VIDPOVIDALNIY 
( id_osoby INT PRIMARY KEY, 
name_osoby VARCHAR(50), 
posada_osoby VARCHAR(30));

INSERT INTO VIDPOVIDALNIY
(id_osoby, name_osoby, posada_osoby) 
VALUES 
(1,'Іванов Іван Іванович', 'Заступник КЧ з озброєння'), 
(2,'Фарбей Артур Русланович', 'Командир 1 батальону'), 
(3,'Влох Сервгій Володимирович', 'Командир 2 батальону'),
(4,'Голуб Олександр Олександрович','Командир 3 батальону'),
(5,'Яшник Владислав Олегович','Начальник Вузла зв"язку'),
(6,'Бондарук Тарас Іванович','Начальник ЦІС'),
(7,'Стозуб Іван Петрович','Начальник ЦЕЖ'),
(8,'Тислів Володимир Володимирович','Командир 1 роти'),
(9,'Лазаренко Євген Сергійович','Командир взводу забезпечення'),
(10,'Степанов Микита Олександрович','Начальник центру прив"язки');

SELECT * FROM OSOBY

CREATE TABLE PIDROZDIL 
(id_pidrozdil INT PRIMARY KEY, 
name_pidrozdil VARCHAR(20), 
commandyr_pidrozdil INT,
zas_count INT);

INSERT INTO PIDROZDIL
(id_pidrozdil, name_pidrozdil, commandyr_pidrozdil,zas_count)
VALUES
(1,'1 батальон',2,2),
(2,'2 батальон',3,1),
(3,'3 батальон',4,3),
(4,'Вузол зв"яку',5,1),
(5,'ЦІС',6,1),
(6,'ЦЕЖ',7,1),
(7,'1 рота',8,1),
(8,'Взвод забезпечення',9,0),
(9,'Центр прив"язки',10,0),
(10,'Командування',1,0);

CREATE TABLE ZVYAZOK
(id_zas INT PRIMARY KEY,
name_zas VARCHAR(20),
komplekt VARCHAR(10),
id_pidrozdil INT);

INSERT INTO ZVYAZOK VALUES
(10001,'Motorola 4800','повний',1),
(10002,'Motorola 4800','повний',1),
(10003,'Motorola 4800','неповний',2),
(50507,'Motorola 4600','повний',3),
(79651,'Motorola 4600','повний',3),
(26548,'TK-1','повний',3),
(32159,'TK-1','повний',4),
(54329,'TK-4','повний',5),
(99845,'Harris 150B','неповний',6),
(65426,'Aselsan','неповний',7);

ALTER TABLE PIDROZDIL ADD FOREIGN KEY (commandyr_pidrozdil) REFERENCES VIDPOVIDALNIY(id_osoby);
ALTER TABLE ZVYAZOK ADD FOREIGN KEY (id_pidrozdil) REFERENCES PIDROZDIL(id_pidrozdil);

UPDATE ZVYAZOK SET komplekt = 'повний' WHERE id_zas=10003;
SELECT * FROM ZVYAZOK;
////////////////
v18
18	білет
1)	Сутність логічного проектування БД. Технологія спрощення концептуальної моделі БД. 

Логічне проєктування — створення схеми бази даних на основі конкретної моделі даних, наприклад, реляційної моделі БД. Для реляційної моделі даних — це набір схем відносин, зазвичай із зазначенням первинних ключів, а також «зв'язків» між відносинами, що представляють собою зовнішні ключі.
Перетворення концептуальної моделі в логічну модель, як правило, здійснюється за формальними правилами. Цей етап може бути в значній мірі автоматизований.
На етапі логічного проєктування враховується специфіка конкретної моделі даних, але може не враховуватися специфіка конкретної СУБД.
Спрощення концептуальної моделі: вилучення бінарних зв’язків «багато-до-багатьох», вилучення складних зв’язків, вилучення багатозначних атрибутів, вилучення зв’язків з атрибутами.
2) Структура каталогів ОС Linux та їх призначення.
Каталог /root. Він є робочим каталогом суперкористувача. Після реєстрації суперкористувач попадає саме в цей каталог.
Каталог /home. Цей каталог використовується для зберігання даних користувачів. В ньому створюються підкаталоги для кожного користувача під тим іменем, під яким реєструється користувач на початку сеанса роботи (login). Тільки в свому каталозі (а також в каталозі /tmp) рядовий користувач може створювати нові підкаталоги і файли.
Каталог /boot. В ньому містяться файли, що використовуються при початковому завантаженні операційної системи (ОС).
Каталоги /bin і /sbin. В цих каталогах містяться: системні утиліти і бінарні (тобто виконувальні) файли, оболонки, файли багатьох зовнішніх команд, редактори та т.п. Головною відмінністю між програмами, що зберігаються в згаданих каталогах є те, що програми з каталогу /sbin можуть бути виконані лише суперкористувачем.
Каталог /lib. В цьому каталозі знаходяться загальні системні бібліотеки. В одному з підкаталогів каталога /lib знаходиться ядро Linux.
Каталог /dev. Тут знаходяться файли, які представляють системні пристрої (термінали, принтери, вінчестери і т.п.).
Каталог /usr. Цей каталог призначено для зберігання файлів, які не змінюються та спільно використовуються різними користувачами. В підкаталогах /usr/bin і /usr/sbin міститься велика кількість програм, які за своїми функціями подібні до каталогів /bin та /sbin. Підкаталог /usr/share містить дані, які переносяться між комп’ютерами з різними операційними системами.
Каталог /mnt. В цьому каталозі знаходаться підкаталоги, що використовуються як точки монтування для інших файлових систем. До підкаталога /mnt/windows підключається файлова система ОС Windows, до підкаталогу /mnt/floppy підключаються дискети і т.д. Імена цих підкаталогів можуть бути змінені.
Каталог /etc. Цей каталог використовується для зберігання конфігураційних файлів ОС. Серед множини підкаталогів дуже важливим є підкаталог /etc/X11, де зберігаються файли конфігурації системи Х Window, а також підкаталог /etc/rc. d, де міститься сценарій початкового завантаження Linux.
Каталог /opt. В цьому каталозі інсталюються додаткові пакети програм.
Каталог /var. Тут зберігаються файли, вміст яких часто змінюється. Найважливіші такі підкаталоги:
/var/log – для зберігання системних журналів;
/var/mail – для організації поштових скриньок користувачів; /var/spool – для організації буферних черг для принтера, пошти і т.п.
Каталог /lost+found. Цей каталог призначений для зберігання пошкоджених даних, які можуть з’явитися після перевірки файлової системи Linux.
Каталог /tmp. Тут зберігаються тимчасові файли системи і користувачів.
Каталог /auto. Цей каталог використовується для конфігурування пристроїв з метою автоматичного знаходження і монтування носіїв інформації в момент їх встановлення.

Перегляд вмісту каталогу здійснюється командою ls. Формат команди:
ls [–опції] [<Каталог>] [<Файл1> <…>]
v18p
create database OBCHISLUVALNA_TECH;
use OBCHISLUVALNA_TECH;
ALTER DATABASE OBCHISLUVALNA_TECH COLLATE Cyrillic_General_CI_AS;

CREATE TABLE VIDPOVIDALNIY 
( id_osoby INT PRIMARY KEY, 
name_osoby VARCHAR(50), 
posada_osoby VARCHAR(30));

INSERT INTO VIDPOVIDALNIY
(id_osoby, name_osoby, posada_osoby) 
VALUES 
(1,'Іванов Іван Іванович', 'Заступник КЧ з озброєння'), 
(2,'Фарбей Артур Русланович', 'Командир 1 батальону'), 
(3,'Влох Сервгій Володимирович', 'Командир 2 батальону'),
(4,'Голуб Олександр Олександрович','Командир 3 батальону'),
(5,'Яшник Владислав Олегович','Начальник Вузла зв"язку'),
(6,'Бондарук Тарас Іванович','Начальник ЦІС'),
(7,'Стозуб Іван Петрович','Начальник ЦЕЖ'),
(8,'Тислів Володимир Володимирович','Командир 1 роти'),
(9,'Лазаренко Євген Сергійович','Командир взводу забезпечення'),
(10,'Степанов Микита Олександрович','Начальник центру прив"язки');

CREATE TABLE PIDROZDIL 
(id_pidrozdil INT PRIMARY KEY, 
name_pidrozdil VARCHAR(20), 
commandyr_pidrozdil INT,
zas_count INT);

INSERT INTO PIDROZDIL
(id_pidrozdil, name_pidrozdil, commandyr_pidrozdil,zas_count)
VALUES
(1,'1 батальон',2,2),
(2,'2 батальон',3,1),
(3,'3 батальон',4,3),
(4,'Вузол зв"яку',5,1),
(5,'ЦІС',6,1),
(6,'ЦЕЖ',7,1),
(7,'1 рота',8,1),
(8,'Взвод забезпечення',9,0),
(9,'Центр прив"язки',10,0),
(10,'Командування',1,0);

CREATE TABLE PEOM
(id_zas INT PRIMARY KEY,
name_zas VARCHAR(20),
komplekt VARCHAR(50),
id_pidrozdil INT);

INSERT INTO PEOM VALUES
(10001,'ASUS-PC','Intel Core i3, HDD 500GB, 4GB RAM',1),
(10002,'ASUS-PC','Intel Core i3, HDD 500GB, 4GB RAM',1),
(10003,'ASUS-PC','Intel Core i3, HDD 500GB, 4GB RAM',2),
(50507,'ACER-NoteBook','Intel Core i3, SSD 256GB, 8GB RAM',3),
(79651,'Alienware-PC','Intel Core i3, HDD 500GB, 16GB RAM',3),
(26548,'Gigabyte-PC','Intel Core i3, HDD 500GB, 8GB RAM',3),
(32159,'ASUS-NoteBook','Intel Core i3, HDD 500GB, 4GB RAM',4),
(54329,'ASUS-PC','Intel Core i5, HDD 1TB, 8GB RAM',5),
(99845,'ASUS-PC','Intel Core i5, HDD 1TB, 4GB RAM',6),
(65426,'ASUS-PC','Intel Dual Core, HDD 500GB, 4GB RAM',7);

ALTER TABLE PIDROZDIL ADD FOREIGN KEY (commandyr_pidrozdil) REFERENCES VIDPOVIDALNIY(id_osoby);
ALTER TABLE PEOM ADD FOREIGN KEY (id_pidrozdil) REFERENCES PIDROZDIL(id_pidrozdil);

INSERT INTO PEOM VALUES
(10008,'ASUS-PC','Intel Core i3, HDD 500GB, 4GB RAM',2);
SELECT * FROM PEOM;
////////////////////////////
1.Механізм транзакцій в Microsoft SQL Server. 
Транзакція - це група інструкцій однієї або декількох баз даних, які або повністю фіксуються, або повністю відкочуються. Транзакції атомарний, узгоджені, ізольовані і стійкі (atomic, consistent, isolated, durable - ACID). Якщо транзакція пройшла успішно, всі інструкції в ній фіксуються. Якщо транзакція завершується помилкою, то якщо хоча б одна інструкція в групі завершується помилкою, виконується відкат всієї групи.
Початок і кінець транзакції залежать від параметра AUTOCOMMIT і інструкцій BEGIN TRANSACTION, COMMIT і ROLLBACK. Azure Synapse Analytics підтримує такі типи транзакцій:
•	Явні транзакції починаються з інструкції BEGIN TRANSACTION і закінчуються інструкцією COMMIT або ROLLBACK.
•	Транзакції з автофіксації автоматично запускаються в рамках сеансу і не починаються з інструкції BEGIN TRANSACTION. Якщо для параметра AUTOCOMMIT встановлено значення ON, кожна інструкція виконується в транзакції, і явні інструкції COMMIT або ROLLBACK не потрібні. Якщо для параметра AUTOCOMMIT встановлено значення OFF, для визначення результату транзакції потрібен інструкція COMMIT або ROLLBACK. У Azure Synapse Analytics транзакції з автофіксації починаються відразу після інструкції COMMIT або ROLLBACK або після інструкції SET AUTOCOMMIT OFF.
Синтаксис( приклад):
BEGIN TRANSACTION [;]  -початок транзакції
INSERT INTO товари ( Дата,[Назва товару], ціна , кількість) VALUES (‘3.3.2005’, ‘Картопля’, 12.50 , 10)-вставляємо рядок даних
UPDATE Товари
SET Ціна = 15
WHERE [Назва товару] LIKE ‘Картопля’- оновити дані в останньому рядку
COMMIT TRANSACTION – виконати транзакцію  
ROLLBACK  TRANSACTION- відмінити транзакцію
SELECT * FROM Товари- вибрати всі дані з таблиці

2.Патерни проектування при проектуванні програмного забезпечення. Структурні шаблони та задачі, які вони вирішують.
Патерн проектування  - це часто зустрічаєме рішення певної проблеми при проектуванні архітектури програм.
На відміну від готових функцій або бібліотек, патерн не можна просто взяти і скопіювати в програму. Патерн є не якийсь конкретний код, а загальна концепція вирішення тієї чи іншої проблеми, яку потрібно буде ще підлаштувати під потреби вашої програми.
Патерни часто плутають з алгоритмами, адже обидва поняття описують типові рішення якихось відомих проблем. Але якщо алгоритм - це чіткий набір дій, то патерн - це високорівневий опис рішення, реалізація якого може відрізнятися в двох різних програмах.

Описи патернів зазвичай дуже формальні і найчастіше складаються з таких пунктів:
•	проблема, яку вирішує патерн;
•	мотивації до вирішення проблеми способом, який пропонує патерн;
•	структури класів, складових рішення;
•	прикладу на одній з мов програмування;
•	особливостей реалізації в різних контекстах;
•	зв'язків з іншими патернами.
Такий формалізм в описі дозволив створити великий каталог патернів, перевіривши кожен з них на спроможність.
Самі низькорівневі і прості патерни - ідіоми . Вони не універсальні, оскільки застосовні тільки в рамках однієї мови програмування.
Самі універсальні - архітектурні патерни , які можна реалізувати практично на будь-якій мові. Вони потрібні для проектування всієї програми, а не окремих її елементів.
Крім того, патерни відрізняються і призначенням:
•	Породжуючі патерни турбуються про гнучке створення об'єктів без внесення в програму   зайвих залежностей.
•	Структурні патерни показують різні способи побудови зв'язків між об'єктами.
•	Поведінкові патерни піклуються про ефективну комунікацію між об'єктами.
Структурні шаблони- шаблони проектування, у яких розглядається питання про те, як із класів та об'єктів утворюються більші за розмірами структури.
Структурні шаблони рівня класу використовують успадкування для утворення композицій із інтерфейсів та реалізацій.
Структурні шаблони рівня об'єкта компонують об'єкти для отримання нової функціональності. Додаткова гнучкість у цьому разі пов'язана з можливістю змінювати композицію об'єктів під час виконання, що є неприпустимим для статичної композиції класів. Виділяють такіструктурні шаблони:
•	Адаптер-це структурний патерн проектування, що дає змогу об’єктам із несумісними інтерфейсами працювати разом.
•	Міст — це структурний патерн проектування, який розділяє один або кілька класів на дві окремі ієрархії — абстракцію та реалізацію, дозволяючи змінювати код в одній гілці класів, незалежно від іншої.
•	Компонувальник — це структурний патерн проектування, що дає змогу згрупувати декілька об’єктів у деревоподібну структуру, а потім працювати з нею так, ніби це одиничний об’єкт.
•	Декоратор — це структурний патерн проектування, що дає змогу динамічно додавати об’єктам нову функціональність, загортаючи їх у корисні «обгортки».
•	Фасад — це структурний патерн проектування, який надає простий інтерфейс до складної системи класів, бібліотеки або фреймворку.
•	Пристосуванець — це структурний патерн проектування, що дає змогу вмістити більшу кількість об’єктів у відведеній оперативній пам’яті. Легковаговик заощаджує пам’ять, розподіляючи спільний стан об’єктів між собою, замість зберігання однакових даних у кожному об’єкті.
•	Заступник — це структурний патерн проектування, що дає змогу підставляти замість реальних об’єктів спеціальні об’єкти-замінники. Ці об’єкти перехоплюють виклики до оригінального об’єкта, дозволяючи зробити щось до чи після передачі виклику оригіналові.

v25p
Готовий варіант:
Ubuntu Server 18.04:
Login: cadet
Password: 1111

Якщо робиш сам:
1)	sudo adduser staff
пароль вказуєш двічі;
2)	якщо не виходить: 
sudo groupdel staff
і спробувати ще раз;
3)	якщо пароль не вказував: 
sudo passwd staff
і змінюєш пароль;
4)	для зміни терміну дії паролю:
sudo nano /etc/login.defs
там шукаєш
PASS_MAX_DAYS,
PASS_MIN_DAYS,
PASS_WARN_AGE
і ставиш напроти свої цифри
(наприклад MAX=7, MIN=1, WARN=3);
зберігаєш і виходиш (Ctrl + X);
5)	створюєш групу:
sudo groupadd study
6)	закидаєш туди стаффа:
sudo usermod –a –G study staff
7)	sudo gpasswd study
і вводиш пароль для групи;
8)	щоб заблочити стаффа на 1 день:
sudo usermod –L –e 1 staff
(sudo usermod –U –e "" staff – щоб розблочити; не потрібно)

Додатково:
щоб переглянути всіх користувачів:
cat /etc/passwd
всі групи:
cat /etc/group
//////////////////////
v19
Білет 19
1.	Засоби автоматизації проектування баз даних. CASE-технології. Види CASE-систем та їх моделей. Компоненти об’єктно-орієнтованих CASE-систем. Характеристика CASE-засобу Power Designer.
1. В сучасних інформаційних технологіях важливе місце приділяється інструментальним засобам і середовищам розробки автоматизованих систем, зокрема, системам розробки й супроводу їх програмне забезпечення. Ці технології й середовища утворюють системи, що мають назву CASE-систем. Серед CASE-систем для концептуального проектування розрізняють: системи функціонального; інформаційного; поведінкового проектування.
Серед інструментальних CASE-систем розрізняють інтегровані комплекси інструментальних засобів для автоматизації всіх етапів життєвого циклу програмного забезпечення (такі системи називають Workbench) і спеціалізовані інструментальні засоби для виконання окремих функцій (Tools). Засоби CASE-систем по своєму функціональному призначенню належать до однієї з наступних груп:
засоби програмування;
засоби керування програмним проектом;
засоби верифікації (аналізу) програм;
засоби документування.
До засобів програмування відносяться компілятори для алгоритмічних мов; будівник діаграм потоків даних; планувальники; інтерпретатори мов; прототайпер для розробки зовнішніх інтерфейсів – екранів, форм вихідних документів, сценаріїв діалогу; генератори програм певних класів; 
Керування програмним проектом називають також керуванням конфігураціями програмного забезпечення. Цьому поняттю відповідають коректне внесення змін в програмну систему при її проектуванні й супроводі, контроль цілісності проектних даних, керування версіями проекту, організація паралельної роботи членів колективу розробників. Використання засобів керування конфігураціями дозволяє створювати програмні системи із сотень і тисяч модулів, значно скорочувати строки розробки, успішно модернізувати вже поставлені замовником задачі.
Засоби верифікації служать для оцінки ефективності виконання розроблювальних програм і визначення наявності в них помилок і протиріч. Розрізняють статичні й динамічні аналізатори. У статичних аналізаторах ПЗ досліджується на наявність невизначених даних, нескінченних циклів, неприпустимих передач керування і т.п. Динамічний аналізатор функціонує в процесі виконання програми, яку перевіряє; при цьому досліджуються траси, виміряються частоти звертань до модулів і т.п. Використовуваний математичний апарат – мережі Петрі, теорія масового обслуговування.
В останню з перерахованих груп входять документатори для оформлення програмної документації, наприклад, звітів по даним репозиторію; різні редактори для об'єднання, поділу, заміни, пошуку фрагментів програм і інших операцій редагування.
Сімейство програмних продуктів Powersoft PowerDesigner є сучасним засобом моделювання і побудови баз даних і додатків в архітектурі клієнт-сервер, який можуть використовувати в своїй роботі аналітики, проектувальники, розробники додатків і баз даних, а також адміністратори баз даних. Модульна структура PowerDesigner дозволяє організаціям вибрати конфігурацію, що відповідає саме їхнім вимогам і розмірам розроблювального проекту. Широкі можливості по аналізу і проектуванню інформаційних систем забезпечують гнучкий структурний підхід, що підвищує ефективність роботи створюваних баз даних і додатків без необхідності слідування вибраної одного разу методології.
Sybase PowerDesigner є комплексним рішенням для моделювання і розробки додатків і бізнес-процесів для організацій, які потребують швидкого, послідовного та ефективного з точки зору витрат створення або реінжинірингу бізнес-додатків.
Можливості PowerDesigner:
-       моделювання бізнес-процесів (ProcessAnalyst);
-       підтримка BPMN;
-       генерація коду (Java, C #, VB. NET, Hibernate, EJB3, NHibernate, JSF, WinForm (.NET та .NET CF), PowerBuilder тощо);
-       моделювання даних (працює з більшістю основних систем СКБД);
-       сховище даних моделювання (WarehouseArchitect);
-       Eclipse Plugin;
-       об'єктне моделювання (UML 2.0 діаграми);
-       генерація звітів;
-       підтримує Simul8 - додає імітаційне моделювання функцій в модуль BPM для покращення дизайну бізнес-процесів;
-       сховище;
-       аналіз вимог;
-       XML-моделювання (XML-схеми і DTD стандарти).

2.	Базові команди маніпуляції об’єктами файлової системи в ОС Linux.
2. В ОС Linux слід розрізняти фізичну файлову систему, яка відповідає за керування дисковим простором і розміщення файлів у фізичних адресах диска та логічну файлову систему, яка забезпечує логічну структуру зберігання файлів - простір імен файлів. ОС Unix і Linux можуть працювати з різними фізичними файловими системами (Ext2, ext3, ufs), логічне ж подання файлової системи Unix/Linux структуровано.
Команди роботи з файлами та директоріями
pwd	Виводить поточний шлях
ls	Виводить список файлів і каталогів по порядку
ls-laX	Виводить форматований список всіх файлів і директорій, включаючи приховані
cd	Перехід в домашню теку
cd /home	Перехід в директорію /home
cd ..	Перехід в каталог рівнем вище того, в якому зараз перебуваєте
cd ../..	Перехід в каталог двома рівнями вище того, в якому зараз перебуваєте
cd -	Перехід в каталог у якому ви перебували до переходу в поточний каталог
touch /home/primer2	Створення порожнього файлу /home/primer2
cat /home/primer2	Показати вміст файлу /home/primer2
tail /var/log/messages	Виводить кінець файлу. Зручно при роботі з великими файлами
head /var/log/messages	Виводить перші рядки файлу
nano /home/primer2	Редагувати файл /home/primer2
sudo tee-a /home/primer2	Додавання до кінця файлу "ОР" в файл /home/primer2
cp /home/Mut@NT/primer.txt /home/primer.txt	Копіює /home/Mut@NT/primer.tx у home/primer.txt
ln-s /home/Mut@NT/primer.txt /home/primer	Створює символічне посилання /home/primer до файлу /home/Mut@NT/primer.txt
mkdir /home/Mut@NT/ОР	Створення директорії з ім'ям ОР
rmdir /home/Mut@NT/ОР	Видалення директорії з ім'ям ОР
rm-rf /home/Mut@NT/ОР	Видалення директорії з вкладеними файлами
cp-la /dir1 /dir2	Копіювання директорій
mv /dir1 /dir2	Перейменування директорії
du-sh /home/Mut@NT/	Виводить на екран розмір заданої директорії. Можна використовувати для визначення розміру файлів (кількість блоків диска, зайнятих кожним файлів у вашому поточному каталозі)
tree	Показує деревоподібний список файлів і тек у вашому поточному каталозі. Також підраховує їх кількість. залежно від кількості файлів підрахунок файлів може зайняти деякий час
dir	Показує вміст вашого поточного каталогу в алфавітному порядку і з урахуванням регістру назв
df	Виводить в консолі кількість зайнятого та вільного місця на жорсткому диску для кожного каталога системи
locate primer	Пошук всіх файлів з ім'ям primer

v19p
create database oblik_os;
use oblik_os;

CREATE TABLE posada(
id_pos INT, 
nazva_pos VARCHAR(30),
PRIMARY KEY (id_pos) 
); 

CREATE TABLE zvanny(
id_zvan INT,
name_zvan VARCHAR(30),
PRIMARY KEY (id_zvan));

CREATE TABLE osob_sklad(
id_os INT,
PIB VARCHAR(30),
rik_nar INT,
nomer_posvid VARCHAR(30),
PRIMARY KEY (id_os),
pos_id INT REFERENCES posada(id_pos),
zvan_id INT REFERENCES zvanny(id_zvan)); 

INSERT INTO posada VALUES 
(1,'Командир батальйону'),
(2,'Заступник командира батальйону'),
(3,'Командир роти'),
(4,'Заступник командира роти'),
(5,'Командир взводу'),
(6,'Командир відділення'),
(7,'Кулеметник'),
(8,'Гранатометник'),
(9,'Стрілець'),
(10,'Водій');

INSERT INTO zvanny VALUES 
(1,'Підполковник'), 
(2,'Майор'),
(3,'Капітан'),
(4,'Ст.Лейтенант'),
(5,'Лейтенант'),
(6,'Мол.Лейтенант'),
(7,'Прапорщик'),
(8,'Сержант'),
(9,'Ст. Солдат'),
(10,'Солдат');

INSERT INTO osob_sklad VALUES 
(1,'Іванов Іван',1972,'АА 315683',1,1),
(2,'Петров Петро',1974,'СВ 867352',2,2),
(3,'Шевченко Олег',1975,'КВ 34747',3,3),
(4,'Морозов Микола',1973,'МА 943721',4,4),
(5,'Сидоров Данило',1980,'ТТ 123456',5,5),
(6,'Проценко Дмитро',1989,'ОР 654321',6,6),
(7,'Бурий Олександр',1990,'АВ 645287',7,7),
(8,'Білий Максим',1977,'УК 878787',8,8),
(9,'Фролов Олексій',1994,'ПМ 473561',9,9),
(10,'Комаров Іван',1991,'ВВ 987567',10,10);

SELECT PIB,rik_nar,nomer_posvid from osob_sklad;
//////////////////////////
v26
1. Процедури, що зберігаються на сервері. Використання процедур в технологіях доступу до баз даних. Синтаксис.

Процедура - це набір операторів SQL, які можуть зберігатися на сервері БД.
Збережена процедура - це сегмент декларативних операторів SQL, що зберігаються в каталозі бази даних. Процедура може бути викликаться тригерами , іншими збереженими процедурами і такими додатками, як Java , Python , PHP , і т.д
Переваги використання:
1.	полегшується програмна частина розробки, тому що частина простих дій здійснює сама БД.
2.	написані функції і процедури можуть бути попередньо скомпільовані, що прискорює виконання.
3.	ізоляція користувачів від таблиць даних. Це дає вам можливість надати доступ до збережених процедур, які керують даними, але не безпосередньо до таблиць.
Недоліки:
1.	збільшене навантаження на сервер бази даних - велика частина роботи виконується на стороні сервера і менше на стороні клієнта.
2.	перенесення на іншу систему управління базами даних може бути важче.
Збережені процедури зберігаються всередині таблиці proc бази mysql .
	Для роботи з збереженими процедурами необхідні такі привілеї для користувача: 
1.	CREATE ROUTINE,
2.	 ALTER ROUTINE,
3.	 EXECUTE.
	Створення збереженої процедури (приклад)
CREATE PROCEDURE citycount (IN country CHAR(3), OUT cities INT)
       BEGIN
         SELECT COUNT(*) INTO cities FROM world.city
         WHERE CountryCode = country;
       END//


2. Мережі Wi-Fi: класифікація протоколів, топологія, принципи роботи, недоліки та переваги.
2.1Класифікація протоколів
Найпоширенішою системою класифікації мережних протоколів (і способів мережного зв'язку загалом) є, так звана, модель OSI
DHCP — протокол динамічного налаштування вузла (Dynamic Host Configuration Protocol). Це протокол, що призначає пристроям у мережі динамічні IP-адреси.
EAP — розтяжний протокол автентифікації (Extensible Authentication Protocol), протокол автентифікації, що використовується у стандарті IEEE 802.1x.
EtherTalk — протокол зв'язку AppleTalk, що керує передачами Ethernet.
ftp — протокол прикладних програм TCP/IP, призначений для передачі файлів.
IEEE 802.1x — стандарт IEEE, що забезпечує автентифікацію у дротових/бездротових мережах. IEEE 802.11b та IEEE 802.11g — стандарти для 2,4 ГГц діапазону бездротових мереж.
lpd — протокол прикладних програм TCP/IP для віддаленого друку.
IPv4 — інтернет-протокол версії 4. Наразі це найпоширеніший формат інтернет-протоколу (IP). Адреси записуються у вигляді 32-розрядних рядків з чотирьох чисел, відокремлених десятковими точками. Діапазон чисел від 0 до 255.
IPv6 — інтернет-протокол версії 6. Розроблений як протидія зменшенню доступних адрес у IPv4. Цей протокол збільшує кількість комп'ютерів, з якими можна працювати, а також посилює функції безпеки тощо. Адреси записуються у вигляді 128-розрядних рядків, завдяки чому кількість IP-адрес майже безкінечна.
Open system authentication (Аутентифікація відкритої системи) — протокол автентифікації точки доступу в бездротовій мережі, з яким бездротовий вузол надсилає запит автентифікації бездротовій точці доступу, яка приймає з'єднання, фактично не автентифікуючи його.
TCP/IP — керуючий протокол передачі/інтернет протокол (Transmission Control Protocol/Internet Protocol), рівень протоколів, який забезпечує зв'язки між вузлами мережі.
WPA-PSK (TKIP/AES) — протокол шифрування Wi-Fi із потужнішим алгоритмом шифрування, ніж WEP. Пристрої та точки доступу повинні використовувати спільний ключ (Pre-Shared key). Протокол, що використовує AES, називається WPA2-PSK та забезпечує краще шифрування, ніж TKIP.

2.2Топологія організації безпровідних мереж в режимі WDS аналогічна вичайним дротовим топологіям.
 
Рис 3.123 режим wds                                                                          Рис. 3.16. Режим повторювача
 
Рис. 3.17. Режим клієнта                                                      		Рис. 3.18. Топологія типу «шина»
 
Рис. 3.19. Топологія типу «кільце»                                                       Рис. 3.20. Топологія типу «зірка»

2.3Принципи роботи
Зазвичай схема мережі Wi-Fi містить не менш однієї точки доступу та може легко масштабуватись.
Також можливо підключення двох клієнтів в режимі точка-точка (Ad-hoc), коли точка доступу не використовується, а клієнти з'єднуються за участю мережевих адаптерів «напряму». Точка доступу передає свій ідентифікатор мережі (SSID) з допомогою спеціальних сигнальних пакетів на швидкості 0,1 Мбіт/с кожні 100 мс. Тому 0,1 Мбіт/с — найменша швидкість передачі даних для Wi-Fi. Знаючи SSID мережі, клієнт може з'ясувати, чи можливо підключення до даної точки доступу. При потраплянні в зону дії двох точок доступу з ідентичними SSID приймач може вибирати між ними на основі даних про рівень сигналу. Стандарт Wi-Fi дає клієнту повну свободу при виборі критеріїв для з'єднання [5].
Однак стандарт не описує всі аспекти побудови безпровідних локальних мереж Wi-Fi. Тому кожен виробник устаткування вирішує цю задачу по-своєму, застосовуючи ті підходи, які він вважає за якнайкращі з тієї або іншої точки зору. Тому виникає необхідність класифікації способів побудови безпровідних локальних мереж.
За способом об'єднання точок доступу в єдину систему можна виділити:
•	Автономні точки доступу (називаються також самостійні, децентралізовані, розумні)
•	Точки доступу, що працюють під управлінням контролера (називаються також «легковагі», централізовані)
•	Безконтролерні, але не автономні (керовані без контролера)
За способом організації і управління радіоканалами можна виділити безпровідні локальні мережі:
•	Із статичними налаштуваннями радіоканалів
•	З динамічними (адаптивними) налаштуваннями радіоканалів
•	З «шаруватою» або багатошаровою структурою радіоканалів

2.4 Переваги та недоліки
Переваги:
1. Відсутність проводів 
2. Мобільність і висока швидкість передачі даних
3. Мережі Wi-Fi не створюють перешкод
4. Wi-Fi безпечний для людини
5. Проста настройка Wi-Fi мереж
6. Wi -Fi модуль може об'єднати всю електроніку в будинку
7. Дешевизна установки і володіння

Недоліки:
1. Великий вплив навколишнього середовища на передачу даних
2. Обмежений радіус дії. У кожного Wi-Fi модуля він свій (може досягати до 500 метрів)
3. На якість зв'язку впливає товщина стін і інші перешкоди
4. Слабкий захист від злому (це тільки поки)
5. Високе енергоспоживання (це страшно для пристроїв, що працюють від акумулятора )
6. через велику кількість точок доступу Wi-Fi в будинку, передача даних погіршується.

v27
27 білет
 1.Організація сервісу Web. Архітектура. Протоколи. Характеристика клієнтів та серверів.

У глобальній мережі Інтернет вся інформація розміщується на Web-сторінках, що написані на мові HTML (HTML-сторінки) або на її розширеннях, таких як DHTML (Dynamic HTML  динамічний HTML) і XML (eХtensible Markup Language  розширена мова розмітки). До вмісту Web-сторінки може входити текстова інформація, посилання на інші Web-сторінки, графічні зображення, аудіо/відеоінформація і інші дані. Відповідні строрінки зберігаються на Web-сервері.
Для доступу до Web-сторінок застосовуються спеціальні клієнтські програми  Web-оглядачі  (програми перегляду гіпертексту, або браузери  від англ. Browser), що встановлені на комп’ютерах користувачів Інтернету. Оглядач формує запит на отримання необхідної сторінки або іншого ресурсу за допомогою спеціальної адреси URL (Universal Resource Locator  універсального покажчика ресурсу). Ця адреса визначає тип протокола для передачі ресурса, ім’я домена, що використовується для доступу до потрібного Web-вузла, номер порту (порт  логічний канал зв’язку, номери визначаються стандартами Інтернету), локальний шлях до файла та додаткові аргументи.
У функції Web-оглядача входить відображення Web-сторінок, що формує Web-сервер. При цьому Web-оглядач встановлює з’єднання з потрібним Web-вузлом, використовуючи протокол HTTP (Hyper Text Transfer Protocol  протокол передачі гіпертексту). Обмін даними на апаратному рівні здійснюється на основі протоколу   TCP / IP.
Центральним об’єктом в HTTP є ресурс, на який вказує URL у запиті клієнта. Зазвичай такими ресурсами є файли, що зберігаються на сервері. Особливістю протоколу HTTP є можливість вказати у запиті та відповіді спосіб представлення одного і того ж ресурсу за різними параметрами: формату, кодування, мови і т. д. Саме завдяки можливості вказівки способу кодування повідомлення клієнт і сервер можуть обмінюватися двійковими даними. 

 

Для організації такої взаїмодії можуть застосовуватися наступні засоби:
	сценарії, що розробляються на різних мовах сценаріїв (РНР, JavaScript, JScript і VBScript) і розміщуються у звичайному Web-документі;
	апплети і сервлети Java;
	елементи управління ActiveX;
	консольні програми, що реалізовані з використанням інтерфейсу CGI;
	ехе-програми, що реалізовані за допомогою інтерфейсу WinCGI;
	динамічні бібліотеки, що реалізовані із застосуванням інтерфейсу ISAPI;
	динамічні сторінки IDC / HTX;
	активні серверні сторінки ASP, ASPx.
Функціонування Web-додатків, що побудовані на основі Інтернет-технологій, базується на основі наступних принципів:
	надійність, що обумовлена стійкістю роботи програмно-апаратних засобів мережі;
	здатність до нарощування (масштабування) Web-додатків мереж, що забезпечується застосуванням багаторівневої архітектури. Це дозволяє виконувати один і той самий Web-додаток практично без переконфігурування для мереж інтранет з різною архітектурою;
	відкритість архітектури Web-додатків, що базується на гнучкій багаторівневій архітектурі, стандартизованих протоколах і форматах документів, доступних для модифікації;
	простота засвоєння та використання Web-додатків, що обумовлена застосуванням однотипного клієнтського програмного забезпечення  оглядача з стандартним графічним інтерфейсом користувача.
Дворівнева архітектура. Базовим протоколом мережі гіпертекстових ресурсів Web є протокол HTTP. У його основу (рис. 4.1) покладено взаємодію „клієнт-сервер”, тобто передбачається, що:
	клієнт (Web-браузер) ініціює з’єднання з Web-сервером шляхом посилки йому запиту.  При  цьому  браузер   декодує  першу  частину  URL (Universal Resource 
 
Рис. 4.1. Дворівнева архітектура „клієнт-сервер” у Web
Locator) і встановлює з’єднання з сервером;
	сервер, отримавши запит, проводить необхідні дії і повертає назад клієнтові відповідь з результатом. 
При цьому можливі два способи організації роботи комп’ютера-клієнта:
	„тонкий” клієнт  це комп’ютер-клієнт, який переносить усі завдання з обробки інформації на сервер. Прикладом тонкого клієнта може служити комп’ютер з браузером, що використовується для роботи з Web-додатками.
	„товстий” клієнт, навпаки, робить обробку інформації незалежно від сервера, використовує останній в основному лише для зберігання даних.
За запитом з боку Web-клієнта Web-сервер може виконувати наступні дії:
	передати Web-клієнту запитаний документ HTML;
	передати Web-клієнту файли MIME-типів (рисунки, сценарії, таблиці стилів, аплети, компоненти ActiveX і т.п.) для переданого документа HTML;
	запустити програму з використанням інтерфейсу CGI (ISAPI), яка може звертатися до зовнішніх програм, отримувати доступ і модифікувати дані в файлах і базах даних (БД);
	з використанням однієї з технологій: включень на стороні сервера  SSI (Server Side Includes), активних серверних сторінок  ASP, ASPx (Active Server Pages), персональних домашніх сторінок  PHP (Personal Home Pages) або серверних сторінок Java  JSP (Java Server Pages) модифікувати вихідний документ HTML перед відправкою його Web-клієнтові, а також отримувати доступ і модифікувати дані в файлах і базах даних на сервері.
На стороні Web-клієнта Web-браузери (Web-browsers) дозволяють сформувати виведення на дисплей Web-сторінки з отриманого від Web-сервера документа HTML і файлів MIME-типів. При формуванні Web-сторінки можуть використовуватися, як вбудовувані модулі Web-браузера, так і зовнішні програми.
Недоліки розглянутої дворівневої архітектури полягають у наступному:
	підвищене навантаження на Web-сервер, що пов’язано з тим, що вся робота з обробки URL-запитів, отриманню інформації з БД і формуванню HTML-сторінок виконується Web-сервером і модулями розширення Web-сервера;
	низький рівень безпеки через неможливість забезпечити необхідний рівень захисту інформації в БД від збоїв під час звернення до бази даних з модуля розширення сервера або конфіденційності інформації БД від адміністратора Web-вузла.
Для подолання зазначених недоліків застосовуються Web-додатки з більшою кількістю рівнів.

2. Типи адрес стеку TCP/IP.  Адреса третього рівня: формат, ієрархічна структура, класи адрес та їх ознаки, технологія формування підмереж. Класова маска. Позакласова маска
Розрізняють три типи адрес стека TCP/IP: локальні, IP-адреси та доменні імена .
Під локальною (апаратною, фізичною) адресою розуміють такий тип адреси, який використовується засобами базової технології для доставки даних в межах підмережі, що є елементом складеної інтер-мережі. В різних підмережах є допустимими різні мережеві технології, різні стеки протоколів, тому при створенні стека TCP/IP передбачалась наявність різних типів локальних адрес.
Для того, щоб в мережі Ethernet стала можливою локальна доставка фреймів, необхідна певна система адресації, тобто присвоєння імен комп’ютерам та інтерфейсум. Кожен вузол має унікальний спосіб само-ідентифікації. Ніякі дві фізичні адреси в мережі не повинні збігатись. Фізичні адреси, які в Ethernet також називають адресами керування доступом до середовища передавання (Media Access Control, MAC), записані в мережевому адаптері ПК або мережевих інтерфейсах пристроїв (маршрутизаторів, комутаторів тощо). MAC-адреса має довжину 48 бітів і записується у вигляді дванадцяти шістнадцяткових цифр (наприклад, 00-60-2F-3A-07-BC). Перші шість цифр, що задаються IEEE, ідентифікують виробника або продавця пристрою і, містять унікальний ідентифікатор організації (Organizationally Unique Identifier – OUI). Другі шість цифр містять серійний номер інтерфейсу або інше значення, що задається конкретним виробником. MAC-адресу іноді називають прошитою (Burned-In Address – BIA), оскільки вона записана в постійній пам’яті (Read-Only Memory – ROM) інтерфейсу або пристрою. Без MAC-адрес локальна мережа являла б собою лише групу ізольованих комп’ютерів, і доставка Ethernet-фреймів була б неможливою. Внаслідок цього на канальному рівні до даних верхніх рівнів додається заголовок, що містить MAC-адресу пристрою та кінцевик. Заголовок та кінцевик містять службову інформацію, призначену для канального рівня пристрою, якому направляється фрейм. Дані верхніх рівнів інкапсулюються в заголовок та кінцевик канального рівня. 
IP-адреси є основним типом адрес, на основі яких мережевий рівень передає пакети між мережами. Ці адреси складаються з 4 байтів і запису-ються у десятково-точковій нотації (наприклад, 195.1.7.26). Кожна з частин адреси, розділених точками, називається октетом (оскільки складається з 8 біт). IP-адреса призначається адміністратором під час конфігурування комп’ютерів та маршрутизаторів.
Символьні доменні імена. Вся мережа Internet побудована на ієрархічній системі адресації. Такий підхід дозволяє здійснювати маршрутизацію, засновану на класах адрес, а не на індивідуальних адресах. Однак використання IP-адрес не дуже зручно для користувачів. Так, різниця між адресами 194.6.197.26 та 194.6.197.62 практично непомітна, хоча обидві адреси належать до різних ресурсів мережі. Ймовірність того, що користувач може помилитьсь і ввести неправильну IP-адресу, досить висока, оскільки числова IP-адреса ніяк не пов’язана з тематикою ресурсу.
Для прив’язування вмісту Web-сторінки та її адреси була розроблена спеціальна система доменних імен (DNS). Служба DNS призначена для трансляції IP-адрес в імена і навпаки. Домен – це група вузлів, що розташовані в одній географічній області, або ж вузлів, що використовуються зі спільною метою. Доменним іменем називають рядок символів і/або цифр, і зазвичай таке ім’я відповідає цифровій IP-адресі Web-вузла в мережі Internet. На сьогодні в мережі Internet існує більш як 200 доменів верхнього (або першого) рівня. Домени першого рівня можуть бути створені за географічною ознакою: .ua – Україна; .ru – Росія; .us – США; .de – Німеччина; .uk – Об’єднане Королівство. Крім того, існує багато загальних доменних імен: .edu – Web-сторінки, присвячені освітнім закладам; .com – комерційні Web-вузли; .gov – урядові вузли; .org – некомерційні вузли; .net – мережеві служби. 
Сервер доменних імен – мережевий пристрій, який за запитом користувача перетворює доменні імена у відповідні IP-адреси і повертає результат клієнту. Система доменних є строго ієрархічною, тому існує декілька рівнів імен і відповідно серверів DNS.



v20p
create database SERVER_TECH;
use SERVER_TECH;
ALTER DATABASE SERVER_TECH COLLATE Cyrillic_General_CI_AS;

CREATE TABLE VIDPOVIDALNIY 
( id_osoby INT PRIMARY KEY, 
name_osoby VARCHAR(50), 
posada_osoby VARCHAR(30));

INSERT INTO VIDPOVIDALNIY
(id_osoby, name_osoby, posada_osoby) 
VALUES 
(1,'Іванов Іван Іванович', 'Заступник КЧ з озброєння'), 
(2,'Фарбей Артур Русланович', 'Командир 1 батальону'), 
(3,'Влох Сервгій Володимирович', 'Командир 2 батальону'),
(4,'Голуб Олександр Олександрович','Командир 3 батальону'),
(5,'Яшник Владислав Олегович','Начальник Вузла зв"язку'),
(6,'Бондарук Тарас Іванович','Начальник ЦІС'),
(7,'Стозуб Іван Петрович','Начальник ЦЕЖ'),
(8,'Тислів Володимир Володимирович','Командир 1 роти'),
(9,'Лазаренко Євген Сергійович','Командир взводу забезпечення'),
(10,'Степанов Микита Олександрович','Начальник центру прив"язки');

CREATE TABLE PIDROZDIL 
(id_pidrozdil INT PRIMARY KEY, 
name_pidrozdil VARCHAR(20), 
commandyr_pidrozdil INT,
zas_count INT);

INSERT INTO PIDROZDIL
(id_pidrozdil, name_pidrozdil, commandyr_pidrozdil,zas_count)
VALUES
(1,'1 батальон',2,2),
(2,'2 батальон',3,1),
(3,'3 батальон',4,3),
(4,'Вузол зв"яку',5,1),
(5,'ЦІС',6,1),
(6,'ЦЕЖ',7,1),
(7,'1 рота',8,1),
(8,'Взвод забезпечення',9,0),
(9,'Центр прив"язки',10,0),
(10,'Командування',1,0);

CREATE TABLE SERV
(id_zas INT PRIMARY KEY,
name_zas VARCHAR(20),
komplekt VARCHAR(50),
id_pidrozdil INT);

INSERT INTO SERV VALUES
(10001,'Swith Cisco 2960','повна',1),
(10002,'Swith Cisco 2960','неповна',1),
(10003,'Swith Cisco 2960','повна',2),
(50507,'Swith Cisco 2960','повна',3),
(79651,'Router Cisco RW340W','неповна',3),
(26548,'Router Cisco RW340W','повна',3),
(32159,'Router Cisco RW340W','неповна',4),
(54329,'Swith Cisco 2960','повна',5),
(99845,'Router Mikrotik 2.4G','повна',6),
(65426,'Router Mikrotik 5G','повна',7);

ALTER TABLE PIDROZDIL ADD FOREIGN KEY (commandyr_pidrozdil) REFERENCES VIDPOVIDALNIY(id_osoby);
ALTER TABLE SERV ADD FOREIGN KEY (id_pidrozdil) REFERENCES PIDROZDIL(id_pidrozdil);

SELECT SERV.id_zas, SERV.name_zas, SERV.komplekt, PIDROZDIL.name_pidrozdil, VIDPOVIDALNIY.name_osoby, VIDPOVIDALNIY.posada_osoby, PIDROZDIL.zas_count FROM SERV 
INNER JOIN PIDROZDIL ON SERV.id_pidrozdil=PIDROZDIL.id_pidrozdil 
INNER JOIN VIDPOVIDALNIY ON PIDROZDIL.commandyr_pidrozdil = VIDPOVIDALNIY.id_osoby;






v?p package com.company;

import java.util.Objects;

public class Person {

    private String name;
    private int age;
    private double weight;

    public Person() {
    }

    public Person(String name, int age, double weight) {
        this.name = name;
        setAge(age);// = age;
        setWeight(weight);
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        if(age > 4 && age < 101){
            this.age = age;
        }
        else {
            this.age = 5;
        }
    }

    public double getWeight() {
        return weight;
    }

    public void setWeight(double weight) {
       if(weight > 100){
           this.weight = 85;
       }
       else {
           this.weight = weight;
       }
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Person)) return false;
        Person person = (Person) o;
        return getAge() == person.getAge() &&
                Double.compare(person.getWeight(), getWeight()) == 0 &&
                Objects.equals(getName(), person.getName());
    }

    @Override
    public int hashCode() {
        return Objects.hash(getName(), getAge(), getWeight());
    }

    public boolean isPersonDryshch(){
        return  this.weight < 50;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", weight=" + weight +
                '}';
    }
}


public class Main {

    public static void main(String[] args) {

        List<Person> group = new ArrayList<>(Arrays.asList(
                new Person("Vasilii", 2, 115),
                new Person("Masha", 13, 100),
                new Person("Petya", 87, 75),
                new Person("Ira", 21, 46),
                new Person("Milana", 10, 35)
        ));
        //group.forEach(p-> System.out.println(p));

        List<Person> lessThan50 = group.stream()
                                       .filter(Person::isPersonDryshch)
                                       .collect(Collectors.toList());
        lessThan50.forEach(System.out::println);
    }
}

v28
Білет 19
1.	Засоби автоматизації проектування баз даних. CASE-технології. Види CASE-систем та їх моделей. Компоненти об’єктно-орієнтованих CASE-систем. Характеристика CASE-засобу Power Designer.
1. В сучасних інформаційних технологіях важливе місце приділяється інструментальним засобам і середовищам розробки автоматизованих систем, зокрема, системам розробки й супроводу їх програмне забезпечення. Ці технології й середовища утворюють системи, що мають назву CASE-систем. Серед CASE-систем для концептуального проектування розрізняють: системи функціонального; інформаційного; поведінкового проектування.
Серед інструментальних CASE-систем розрізняють інтегровані комплекси інструментальних засобів для автоматизації всіх етапів життєвого циклу програмного забезпечення (такі системи називають Workbench) і спеціалізовані інструментальні засоби для виконання окремих функцій (Tools). Засоби CASE-систем по своєму функціональному призначенню належать до однієї з наступних груп:
засоби програмування;
засоби керування програмним проектом;
засоби верифікації (аналізу) програм;
засоби документування.
До засобів програмування відносяться компілятори для алгоритмічних мов; будівник діаграм потоків даних; планувальники; інтерпретатори мов; прототайпер для розробки зовнішніх інтерфейсів – екранів, форм вихідних документів, сценаріїв діалогу; генератори програм певних класів; 
Керування програмним проектом називають також керуванням конфігураціями програмного забезпечення. Цьому поняттю відповідають коректне внесення змін в програмну систему при її проектуванні й супроводі, контроль цілісності проектних даних, керування версіями проекту, організація паралельної роботи членів колективу розробників. Використання засобів керування конфігураціями дозволяє створювати програмні системи із сотень і тисяч модулів, значно скорочувати строки розробки, успішно модернізувати вже поставлені замовником задачі.
Засоби верифікації служать для оцінки ефективності виконання розроблювальних програм і визначення наявності в них помилок і протиріч. Розрізняють статичні й динамічні аналізатори. У статичних аналізаторах ПЗ досліджується на наявність невизначених даних, нескінченних циклів, неприпустимих передач керування і т.п. Динамічний аналізатор функціонує в процесі виконання програми, яку перевіряє; при цьому досліджуються траси, виміряються частоти звертань до модулів і т.п. Використовуваний математичний апарат – мережі Петрі, теорія масового обслуговування.
В останню з перерахованих груп входять документатори для оформлення програмної документації, наприклад, звітів по даним репозиторію; різні редактори для об'єднання, поділу, заміни, пошуку фрагментів програм і інших операцій редагування.
Сімейство програмних продуктів Powersoft PowerDesigner є сучасним засобом моделювання і побудови баз даних і додатків в архітектурі клієнт-сервер, який можуть використовувати в своїй роботі аналітики, проектувальники, розробники додатків і баз даних, а також адміністратори баз даних. Модульна структура PowerDesigner дозволяє організаціям вибрати конфігурацію, що відповідає саме їхнім вимогам і розмірам розроблювального проекту. Широкі можливості по аналізу і проектуванню інформаційних систем забезпечують гнучкий структурний підхід, що підвищує ефективність роботи створюваних баз даних і додатків без необхідності слідування вибраної одного разу методології.
Sybase PowerDesigner є комплексним рішенням для моделювання і розробки додатків і бізнес-процесів для організацій, які потребують швидкого, послідовного та ефективного з точки зору витрат створення або реінжинірингу бізнес-додатків.
Можливості PowerDesigner:
-       моделювання бізнес-процесів (ProcessAnalyst);
-       підтримка BPMN;
-       генерація коду (Java, C #, VB. NET, Hibernate, EJB3, NHibernate, JSF, WinForm (.NET та .NET CF), PowerBuilder тощо);
-       моделювання даних (працює з більшістю основних систем СКБД);
-       сховище даних моделювання (WarehouseArchitect);
-       Eclipse Plugin;
-       об'єктне моделювання (UML 2.0 діаграми);
-       генерація звітів;
-       підтримує Simul8 - додає імітаційне моделювання функцій в модуль BPM для покращення дизайну бізнес-процесів;
-       сховище;
-       аналіз вимог;
-       XML-моделювання (XML-схеми і DTD стандарти).

2.	Базові команди маніпуляції об’єктами файлової системи в ОС Linux.
2. В ОС Linux слід розрізняти фізичну файлову систему, яка відповідає за керування дисковим простором і розміщення файлів у фізичних адресах диска та логічну файлову систему, яка забезпечує логічну структуру зберігання файлів - простір імен файлів. ОС Unix і Linux можуть працювати з різними фізичними файловими системами (Ext2, ext3, ufs), логічне ж подання файлової системи Unix/Linux структуровано.
Команди роботи з файлами та директоріями
pwd	Виводить поточний шлях
ls	Виводить список файлів і каталогів по порядку
ls-laX	Виводить форматований список всіх файлів і директорій, включаючи приховані
cd	Перехід в домашню теку
cd /home	Перехід в директорію /home
cd ..	Перехід в каталог рівнем вище того, в якому зараз перебуваєте
cd ../..	Перехід в каталог двома рівнями вище того, в якому зараз перебуваєте
cd -	Перехід в каталог у якому ви перебували до переходу в поточний каталог
touch /home/primer2	Створення порожнього файлу /home/primer2
cat /home/primer2	Показати вміст файлу /home/primer2
tail /var/log/messages	Виводить кінець файлу. Зручно при роботі з великими файлами
head /var/log/messages	Виводить перші рядки файлу
nano /home/primer2	Редагувати файл /home/primer2
sudo tee-a /home/primer2	Додавання до кінця файлу "ОР" в файл /home/primer2
cp /home/Mut@NT/primer.txt /home/primer.txt	Копіює /home/Mut@NT/primer.tx у home/primer.txt
ln-s /home/Mut@NT/primer.txt /home/primer	Створює символічне посилання /home/primer до файлу /home/Mut@NT/primer.txt
mkdir /home/Mut@NT/ОР	Створення директорії з ім'ям ОР
rmdir /home/Mut@NT/ОР	Видалення директорії з ім'ям ОР
rm-rf /home/Mut@NT/ОР	Видалення директорії з вкладеними файлами
cp-la /dir1 /dir2	Копіювання директорій
mv /dir1 /dir2	Перейменування директорії
du-sh /home/Mut@NT/	Виводить на екран розмір заданої директорії. Можна використовувати для визначення розміру файлів (кількість блоків диска, зайнятих кожним файлів у вашому поточному каталозі)
tree	Показує деревоподібний список файлів і тек у вашому поточному каталозі. Також підраховує їх кількість. залежно від кількості файлів підрахунок файлів може зайняти деякий час
dir	Показує вміст вашого поточного каталогу в алфавітному порядку і з урахуванням регістру назв
df	Виводить в консолі кількість зайнятого та вільного місця на жорсткому диску для кожного каталога системи
locate primer	Пошук всіх файлів з ім'ям primer


v29
Білет 29
1.	Поняття інформаційної мережі. Послуги інформаційної мережі, служби і платформи надання послуг. 
1.  Інформаційна мережа — призначена для зберігання інформації і складається з інформаційних систем. На базі комунікаційної мережі може бути побудована група інформаційних мереж. Під інформаційною системою слід розуміти систему, яка є постачальником або споживачем інформації. Іншими словами — об'єкт, здатний здійснювати зберігання, обробку або передачу інформація. До складу інформаційної системи входять: комп'ютери, програми, користувачі і інші складові, призначені для процесу обробки і передачі даних. Надалі інформаційна система, призначена для вирішення завдань користувача, називатиметься — робоча станція (client). Робоча станція в мережі відрізняється від звичайного персонального комп'ютера (ПК) наявністю мережевої карти (мережевого адаптера), каналу для передачі даних і мережевого програмного забезпечення. Інформаційна мережа складається:
з абонентських і адміністративних систем;
комунікаційної мережі, що їх з'єднує.
2.	Стадії автоматизації документообігу. Загальні принципи побудови системи електронного документообігу. Основні вимоги до систем електронного документообігу.


v30
Білет 30
1.	Принципи роботи системи контролю версіями Git.
1.  Система контролю версій Git- це система, що записує зміни у файл або набір файлів протягом деякого часу, так що ви зможете повернутися до певної версії пізнише. Як приклад, в цій книзі, для файлів, що знаходяться під контролем версій, буде використовуватися код програмного забезпечення, хоча насправді ви можете використовувати контроль версій практично для будь-яких типів файлів.
Якщо ви графічний або веб-дизайнер і хочете зберегти кожну версію зображення або макета (швидше за все, захочете), система контролю версій (далі СКВ) якраз те, що потрібно. Вона дозволяє повернути вибрані файли до попереднього стану, повернути весь проект до попереднього стану, побачити зміни, побачити, хто останній міняв щось і спровокував проблему, хто вказав на проблему і коли, та багато іншого. Використання СКВ (система керування версіями) також в цілому означає, що, якщо ви зламали щось або втратили файли, ви просто можете все виправити. Крім того, ви отримаєте все це за дуже невеликі накладні витрати.
Варто сказати, що система якщо й не викликала фурор, то трохи сколихнула співтовариство в області СУВ (система управління версіями) своєю новизною і запропонувала новий шлях розвитку. Git надає гнучкі і прості у використанні інструменти для ведення історії проекту.
Особливістю Git є те, що робота над версіями проекту може відбуватися не в хронологічному порядку. Розробка може вестися в декількох паралельних гілках, які можуть зливатися і розділятися в будь-який момент проектування.
Git - досить гнучка система, і область її застосування обмежується не тільки сферою розробки. Наприклад, журналісти, автори технічної літератури, адміністратори, викладачі вузів цілком можуть використовувати її в своєму роді діяльності. До таких завдань можна віднести контроль версій будь-якої документації, доповіді, домашніх завдань.
Виділимо основні відмінності Git від інших розподілених і централізованих СУВ.
2.	Керівні документи, що регламентують документообіг в ЗСУ. Порядок проходження документів згідно визначених термінів їх розгляду та опрацювання. 
2. Керівні документи з діловодства у ЗС України. 
	Закон України від 21.08. 1999 № 1079 (зі змінами) „Про державну таємницю”.
	Постанова КМУ від 14.04.97 № 348 (зі змінами) „Інструкція з діловодства за зверненнями
   громадян”. 
	Постанова КМУ від 17.10.97 № 1153 (зі змінами)  „Інструкція з діловодства. Примірна”.
	Постанова КМУ від 21.11.98 № 1893 (зі змінами) „Інструкція про порядок обліку, 
   зберігання і використання документів, справ, видань та інших матеріальних носіїв, 
  які містять конфіденційну інформацію, що є власністю держави”.
	Постанова КМУ від 02.10.03 № 1561-12 „Порядок організації та забезпечення режиму 
   секретності в органах державної влади, органах місцевого самоврядування,
   на підприємствах, в установах і організаціях”. 
	Наказ МОУ від 21.11.2012 № 777 „Про затвердження Інструкції з діловодства
    в Міністерстві оборони України та Генеральному штабі Збройних Сил України”.
	Наказ МОУ від 30.03.99 № 101 (зі змінами) „Про порядок підготовки, подання на підпис, 
   видання та розсилки наказів і директив МОУ”. 
	Наказ МОУ від 18.11.03 № 401 (зі змінами) „Про затвердження Переліку документів, що
   утворюються в діяльності МО України та ЗС України, із зазначенням строків зберігання
   документів”.
	Наказ МОУ від 16.10.06 № 600 „Про затвердження Інструкції з порядку охорони
   державної таємниці в МО України та ЗС України”.
	Наказ МОУ від 21.11.12 № 777  „Про затвердження Інструкції з діловодства в 
  Міністерстві оборони України та Генеральному штабі Збройних Сил України”.
	Наказ СБУ  від 12.08.05 № 440 (зі змінами) „Звід відомостей, що становлять державну 
  таємницю”.
	Наказ НГШ від 20.09.11 № 180 „Про затвердження Переліку службової інформації 
   Збройних Сил України”.



